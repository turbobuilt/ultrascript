// UltraScript FFI Integration Test
// This test demonstrates that FFI is properly integrated into the UltraScript runtime

// Import the FFI system
import FFI from "./ffi.uts";

console.log("=== UltraScript FFI Integration Test ===");

// Test 1: Basic library loading
console.log("1. Testing basic library loading...");
try {
    const mathLib = FFI.dlopen("libm.so.6");
    console.log("âœ“ Math library loaded successfully");
    mathLib.close();
} catch (error) {
    console.log("âœ— Math library loading failed:", error.message);
}

// Test 2: System library integration
console.log("\n2. Testing system library integration...");
try {
    const cLib = FFI.dlopen("libc.so.6");
    const getpid = cLib.func_specialized("getpid", "i64()");
    const pid = getpid();
    console.log("âœ“ System integration successful, PID:", pid);
    cLib.close();
} catch (error) {
    console.log("âœ— System integration failed:", error.message);
}

// Test 3: Memory management
console.log("\n3. Testing FFI memory management...");
try {
    const buffer = FFI.malloc(1024);
    FFI.memset(buffer, 0xAA, 1024);
    console.log("âœ“ Memory allocation and manipulation successful");
    FFI.free(buffer);
    console.log("âœ“ Memory freed successfully");
} catch (error) {
    console.log("âœ— Memory management failed:", error.message);
}

// Test 4: High-performance array operations
console.log("\n4. Testing high-performance operations...");
try {
    const vectorLib = FFI.create_fast_library("./libc.so.6", [
        { name: "malloc", signature: "ptr(i64)" },
        { name: "free", signature: "void(ptr)" },
        { name: "memcpy", signature: "ptr(ptr,ptr,i64)" }
    ]);
    
    const size = 1000000; // 1M bytes
    const array1 = vectorLib.malloc(size);
    const array2 = vectorLib.malloc(size);
    
    // Ultra-fast copy
    const start = performance.now();
    vectorLib.memcpy(array2, array1, size);
    const end = performance.now();
    
    console.log(`âœ“ Copied ${size} bytes in ${(end - start).toFixed(3)}ms`);
    
    vectorLib.free(array1);
    vectorLib.free(array2);
    vectorLib.close();
} catch (error) {
    console.log("âœ— High-performance operations failed:", error.message);
}

// Test 5: Function signature optimization
console.log("\n5. Testing function signature optimization...");
try {
    const lib = FFI.dlopen("libc.so.6");
    
    // Test different calling patterns
    const malloc_generic = lib.func("malloc");
    const malloc_specialized = lib.func_specialized("malloc", "ptr(i64)");
    
    const ptr1 = malloc_generic.call_ptr(1024);
    const ptr2 = malloc_specialized(1024);
    
    console.log("âœ“ Both generic and specialized calls work");
    
    const free_func = lib.func("free");
    free_func.call_void(ptr1);
    free_func.call_void(ptr2);
    
    lib.close();
} catch (error) {
    console.log("âœ— Function signature optimization failed:", error.message);
}

// Test 6: Error handling
console.log("\n6. Testing error handling...");
try {
    const invalidLib = FFI.dlopen("nonexistent_library.so");
    console.log("âœ— Should have failed to load invalid library");
} catch (error) {
    console.log("âœ“ Error handling works correctly:", error.message);
}

// Test 7: Performance benchmark
console.log("\n7. Performance benchmark...");
try {
    const lib = FFI.dlopen("libc.so.6");
    const clock_func = lib.func_specialized("clock", "i64()");
    
    const iterations = 1000000;
    const start_clock = clock_func();
    
    // Call a fast function many times
    for (let i = 0; i < iterations; i++) {
        clock_func();
    }
    
    const end_clock = clock_func();
    const calls_per_second = iterations / ((end_clock - start_clock) / 1000000.0);
    
    console.log(`âœ“ Performance: ${calls_per_second.toFixed(0)} FFI calls/second`);
    
    lib.close();
} catch (error) {
    console.log("âœ— Performance benchmark failed:", error.message);
}

console.log("\n=== FFI Integration Test Complete ===");
console.log("UltraScript FFI system ready for production use!");

// Test 8: Advanced integration patterns
console.log("\n8. Testing advanced integration patterns...");

class NativeAcceleratedArray {
    private lib: any;
    private buffer: any;
    private size: number;
    
    constructor(size: number) {
        this.size = size;
        this.lib = FFI.dlopen("libc.so.6");
        this.buffer = this.lib.func_specialized("malloc", "ptr(i64)")(size * 8);
        
        // Zero initialize
        this.lib.func_specialized("memset", "ptr(ptr,i64,i64)")(this.buffer, 0, size * 8);
    }
    
    fill(value: number): void {
        // Use native memset for ultra-fast filling
        const byte_value = value & 0xFF;
        this.lib.func_specialized("memset", "ptr(ptr,i64,i64)")(this.buffer, byte_value, this.size * 8);
    }
    
    copy_from(other: NativeAcceleratedArray): void {
        const copy_size = Math.min(this.size, other.size) * 8;
        this.lib.func_specialized("memcpy", "ptr(ptr,ptr,i64)")(this.buffer, other.buffer, copy_size);
    }
    
    free(): void {
        if (this.buffer) {
            this.lib.func("free").call_void(this.buffer);
            this.buffer = null;
            this.lib.close();
        }
    }
}

const array1 = new NativeAcceleratedArray(100000);
const array2 = new NativeAcceleratedArray(100000);

array1.fill(0xAA);
array2.copy_from(array1);

console.log("âœ“ Advanced native-accelerated array operations successful");

array1.free();
array2.free();

console.log("\nðŸš€ UltraScript FFI integration complete and fully functional! ðŸš€");
