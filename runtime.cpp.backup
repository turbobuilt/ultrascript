#include "runtime.h"
#include "compiler.h"
#include "lexical_scope.h"
#include "regex.h"
#include "goroutine_system.h"
#include <iostream>
#include <algorithm>
#include <chrono>
#include <unordered_map>
#include <pthread.h>
#include <signal.h>
#include <setjmp.h>
#include <cmath>
#include <regex>
#include <cstring>

// Forward declarations for new goroutine system
extern "C" {
    int64_t __gots_set_timeout(void* callback, int64_t delay_ms);
    int64_t __gots_set_interval(void* callback, int64_t delay_ms);  
    bool __gots_clear_timeout(int64_t timer_id);
    bool __gots_clear_interval(int64_t timer_id);
    void __new_goroutine_system_init();
    void __new_goroutine_system_cleanup();
    void __new_goroutine_spawn(void* func_ptr);
}

// External function declarations
extern "C" void* __lookup_function_by_id(int64_t function_id);

// Global function ID to pointer map
static std::unordered_map<int64_t, void*> g_function_id_map;
static std::mutex g_function_id_mutex;
static std::atomic<int64_t> g_next_function_id{1};

// Global console output mutex for thread safety
std::mutex g_console_mutex;



// Global instances
// Using pointers to control initialization/destruction order
static GoroutineScheduler* global_scheduler = nullptr;
static std::mutex scheduler_mutex;

// Timer globals moved to goroutine_system.cpp to avoid duplicates

ThreadPool::ThreadPool(size_t num_threads) {
    // Use the full number of available hardware threads for maximum performance
    // This is essential for proper goroutine parallelism
    size_t optimal_thread_count = (num_threads > 0) ? num_threads : std::thread::hardware_concurrency();
    
    for (size_t i = 0; i < optimal_thread_count; ++i) {
        workers.emplace_back([this] {
            while (true) {
                std::function<void()> task;
                
                {
                    std::unique_lock<std::mutex> lock(queue_mutex);
                    condition.wait(lock, [this] { return stop.load() || !tasks.empty(); });
                    
                    if (stop.load() && tasks.empty()) {
                        return;
                    }
                    
                    if (!tasks.empty()) {
                        task = std::move(tasks.front());
                        tasks.pop();
                    }
                }
                
                if (task) {
                    try {
                        task();
                    } catch (const std::exception& e) {
                        std::cerr << "Worker task failed: " << e.what() << std::endl;
                    } catch (...) {
                        std::cerr << "Worker task failed with unknown exception" << std::endl;
                    }
                }
            }
        });
    }
}

ThreadPool::~ThreadPool() {
    shutdown();
}

void ThreadPool::shutdown() {
    stop.store(true);
    condition.notify_all();
    
    for (std::thread& worker : workers) {
        if (worker.joinable()) {
            worker.join();
        }
    }
}

void ThreadPool::enqueue_simple(std::function<void()> task) {
    {
        std::unique_lock<std::mutex> lock(queue_mutex);
        
        if (stop.load()) {
            return; // Don't enqueue if stopped
        }
        
        tasks.push(task);
    }
    
    condition.notify_one();
}

// Old GoroutineScheduler implementations removed - using new system

// Global object registry
std::unordered_map<int64_t, std::unique_ptr<ObjectInstance>> object_registry;
std::atomic<int64_t> next_object_id{1};

// High-Performance Function Registry Implementation
FunctionEntry g_function_table[MAX_FUNCTIONS];
std::atomic<uint16_t> g_next_function_id{1};  // Start at 1, 0 is reserved for "invalid"

// Global promise registry for cleanup
static std::unordered_set<void*> g_allocated_promises;
static std::mutex g_promise_registry_mutex;

// Helper function to create and track a promise
static void* create_tracked_promise(std::shared_ptr<Promise> promise) {
    auto* promise_ptr = new std::shared_ptr<Promise>(promise);
    
    // Track allocated promise for cleanup
    {
        std::lock_guard<std::mutex> lock(g_promise_registry_mutex);
        g_allocated_promises.insert(promise_ptr);
    }
    
    return promise_ptr;
}

// Global executable memory info for thread-safe access
ExecutableMemoryInfo g_executable_memory = {nullptr, 0, {}};

extern "C" {

// Function ID registration and lookup
void __register_function_id(int64_t function_id, void* function_ptr) {
    std::lock_guard<std::mutex> lock(g_function_id_mutex);
    g_function_id_map[function_id] = function_ptr;
}

// __lookup_function_by_id is now defined in ast_codegen.cpp to avoid duplicate symbol

int64_t __allocate_function_id() {
    return g_next_function_id.fetch_add(1);
}


// High-Performance Function Registration - O(1) access
uint16_t __register_function_fast(void* func_ptr, uint16_t arg_count, uint8_t calling_convention) {
    uint16_t func_id = g_next_function_id.fetch_add(1);
    
    if (func_id >= MAX_FUNCTIONS) {
        std::cerr << "ERROR: Function table overflow! Maximum " << MAX_FUNCTIONS << " functions supported." << std::endl;
        return 0;  // Return invalid ID
    }
    
    FunctionEntry& entry = g_function_table[func_id];
    entry.func_ptr = func_ptr;
    entry.arg_count = arg_count;
    entry.calling_convention = calling_convention;
    entry.flags = 0;
    
    return func_id;
}

void* __lookup_function_fast(uint16_t func_id) {
    if (func_id == 0 || func_id >= g_next_function_id.load()) {
        return nullptr;  // Invalid function ID
    }
    
    return g_function_table[func_id].func_ptr;
}

// Initialize the new goroutine system
void __runtime_init() {
    // Initialize function table
    for (size_t i = 0; i < MAX_FUNCTIONS; i++) {
        g_function_table[i].func_ptr = nullptr;
    }
    __new_goroutine_system_init();
}

// Main cleanup - wait for all goroutines
void __runtime_cleanup() {
    __new_goroutine_system_cleanup();
}

// Main goroutine functions moved to goroutine_system.cpp

// Optimized goroutine spawn with direct function IDs - NO string lookups
void* __goroutine_spawn_fast(uint16_t func_id) {
    void* func_ptr = __lookup_function_fast(func_id);
    if (!func_ptr) {
        std::cerr << "ERROR: Invalid function ID: " << func_id << std::endl;
        return nullptr;
    }
    
    // Create a task that calls the function directly - minimal overhead
    auto task = [func_ptr]() {
        typedef int64_t (*FuncType)();
        FuncType func = reinterpret_cast<FuncType>(func_ptr);
        return func();
    };
    
    GoroutineScheduler::instance().spawn(task);
    return reinterpret_cast<void*>(1);
}

void* __goroutine_spawn_fast_arg1(uint16_t func_id, int64_t arg1) {
    void* func_ptr = __lookup_function_fast(func_id);
    if (!func_ptr) {
        std::cerr << "ERROR: Invalid function ID: " << func_id << std::endl;
        return nullptr;
    }
    
    // Create a task that calls the function with one argument - minimal overhead
    auto task = [func_ptr, arg1]() {
        typedef int64_t (*FuncType)(int64_t);
        FuncType func = reinterpret_cast<FuncType>(func_ptr);
        return func(arg1);
    };
    
    GoroutineScheduler::instance().spawn(task);
    return reinterpret_cast<void*>(1);
}

void* __goroutine_spawn_fast_arg2(uint16_t func_id, int64_t arg1, int64_t arg2) {
    void* func_ptr = __lookup_function_fast(func_id);
    if (!func_ptr) {
        std::cerr << "ERROR: Invalid function ID: " << func_id << std::endl;
        return nullptr;
    }
    
    // Create a task that calls the function with two arguments - minimal overhead
    auto task = [func_ptr, arg1, arg2]() {
        typedef int64_t (*FuncType)(int64_t, int64_t);
        FuncType func = reinterpret_cast<FuncType>(func_ptr);
        return func(arg1, arg2);
    };
    
    GoroutineScheduler::instance().spawn(task);
    return reinterpret_cast<void*>(1);
}

// Proper array creation that creates a UltraScript TypedArray
void* __array_create(int64_t size) {
    
    // Create a simple TypedArray-like structure
    // For now, use a basic implementation that can be extended
    struct SimpleArray {
        int64_t size;
        void** data;
    };
    
    SimpleArray* array = new SimpleArray;
    array->size = size;
    array->data = size > 0 ? new void*[size] : nullptr;
    
    // Initialize to nullptr
    for (int64_t i = 0; i < size; i++) {
        array->data[i] = nullptr;
    }
    
    return array;
}

// Missing utility functions
void __set_executable_memory(void* memory, size_t size) {
    // Set the global executable memory pointer
    std::lock_guard<std::mutex> lock(g_executable_memory.mutex);
    g_executable_memory.ptr = memory;
    g_executable_memory.size = size;
}

void __console_log(const char* message) {
    std::cout << message;
}

void __console_log_newline() {
    std::cout << std::endl;
}

void __console_log_space() {
    std::cout << " ";
}

void __console_log_number(int64_t value) {
    std::lock_guard<std::mutex> lock(g_console_mutex);
    std::cout << value;
    std::cout.flush();
}

void __console_log_auto(int64_t value) {
    // Check if it's a likely heap pointer (string or object)
    if (value > 0x100000) {  // Likely a heap pointer
        // Try to safely read the string by using the __console_log_string function
        // This way we use the existing safe string handling
        void* ptr = reinterpret_cast<void*>(value);
        
        // Try to call the string logger directly and see if it works
        try {
            __console_log_string(ptr);
            return;
        } catch (...) {
            // String printing failed, try other types
        }
        
        // Check if it might be an object ID
        if (object_registry.find(value) != object_registry.end()) {
            __console_log_object(value);
            return;
        }
    }
    
    // Default: treat as number
    std::cout << value;
}

void __console_log_string(void* string_ptr) {
    std::lock_guard<std::mutex> lock(g_console_mutex);
    if (string_ptr) {
        // Handle basic char* strings
        const char* str = static_cast<const char*>(string_ptr);
        std::cout << str;
        std::cout.flush();
    }
}

void __console_log_object(int64_t object_id) {
    auto it = object_registry.find(object_id);
    if (it != object_registry.end()) {
        std::cout << "[object Object]";
    } else {
        std::cout << "Object#" << object_id;
    }
}

// Helper function to extract C string from GoTSString pointer
const char* __gots_string_to_cstr(void* gots_string_ptr) {
    if (!gots_string_ptr) {
        return "";
    }
    GoTSString* str = static_cast<GoTSString*>(gots_string_ptr);
    return str->c_str();
}

// Stub function for unimplemented runtime functions
void __runtime_stub_function() {
    // Do nothing - just return
}

// Forward declarations for timer functions
extern "C" int64_t __gots_set_timeout(void* callback, int64_t delay_ms);
extern "C" int64_t __gots_set_interval(void* callback, int64_t delay_ms);  
extern "C" bool __gots_clear_timeout(int64_t timer_id);
extern "C" bool __gots_clear_interval(int64_t timer_id);

// Stub implementations for functions used by runtime_syscalls.cpp
void* __string_create(const char* str) {
    return (void*)strdup(str);
}

// String interning for literals - simple implementation for now
void* __string_intern(const char* str) {
    // For now, just return a copy - could optimize with interning later
    return (void*)strdup(str);
}

// Object management implementation
static std::unordered_map<int64_t, ObjectInstance*> g_object_instances;
static std::atomic<int64_t> g_next_object_id{1};
static std::mutex g_object_mutex;

extern "C" int64_t __object_create(const char* class_name, int64_t property_count) {
    std::lock_guard<std::mutex> lock(g_object_mutex);
    
    int64_t object_id = g_next_object_id.fetch_add(1);
    ObjectInstance* instance = new ObjectInstance(std::string(class_name), property_count);
    g_object_instances[object_id] = instance;
    
    return object_id;
}

extern "C" void __object_set_property(int64_t object_id, int64_t property_index, int64_t value) {
    std::lock_guard<std::mutex> lock(g_object_mutex);
    
    auto it = g_object_instances.find(object_id);
    if (it != g_object_instances.end()) {
        ObjectInstance* instance = it->second;
        if (property_index >= 0 && property_index < instance->property_count) {
            instance->property_data[property_index] = value;
        }
    }
}

extern "C" int64_t __object_get_property(int64_t object_id, int64_t property_index) {
    std::lock_guard<std::mutex> lock(g_object_mutex);
    
    auto it = g_object_instances.find(object_id);
    if (it != g_object_instances.end()) {
        ObjectInstance* instance = it->second;
        if (property_index >= 0 && property_index < instance->property_count) {
            return instance->property_data[property_index];
        }
    }
    
    return 0; // Default value
}

extern "C" void __object_destroy(int64_t object_id) {
    std::lock_guard<std::mutex> lock(g_object_mutex);
    
    auto it = g_object_instances.find(object_id);
    if (it != g_object_instances.end()) {
        delete it->second;
        g_object_instances.erase(it);
    }
}

extern "C" void __dynamic_set_property(int64_t object_id, const char* property_name, int64_t value) {
    std::lock_guard<std::mutex> lock(g_object_mutex);
    
    auto it = g_object_instances.find(object_id);
    if (it != g_object_instances.end()) {
        ObjectInstance* instance = it->second;
        instance->properties[std::string(property_name)] = value;
    }
}

extern "C" int64_t __dynamic_get_property(int64_t object_id, const char* property_name) {
    std::lock_guard<std::mutex> lock(g_object_mutex);
    
    auto it = g_object_instances.find(object_id);
    if (it != g_object_instances.end()) {
        ObjectInstance* instance = it->second;
        auto prop_it = instance->properties.find(std::string(property_name));
        if (prop_it != instance->properties.end()) {
            return prop_it->second;
        }
    }
    
    return 0; // Default value
}

extern "C" void __object_set_property_name(int64_t object_id, int64_t property_index, const char* property_name) {
    std::lock_guard<std::mutex> lock(g_object_mutex);
    
    auto it = g_object_instances.find(object_id);
    if (it != g_object_instances.end()) {
        ObjectInstance* instance = it->second;
        if (property_index >= 0 && property_index < instance->property_count) {
            instance->property_names[property_index] = std::string(property_name);
        }
    }
}

extern "C" const char* __object_get_property_name(int64_t object_id, int64_t property_index) {
    std::lock_guard<std::mutex> lock(g_object_mutex);
    
    auto it = g_object_instances.find(object_id);
    if (it != g_object_instances.end()) {
        ObjectInstance* instance = it->second;
        if (property_index >= 0 && property_index < instance->property_count) {
            return instance->property_names[property_index].c_str();
        }
    }
    
    return ""; // Default value
}

void __array_push(void* array, int64_t value) {
    // Basic stub - do nothing for now
    (void)array;
    (void)value;
}

// Simplified Array runtime functions
extern "C" void* __simple_array_create(double* values, int64_t size) {
    Array* arr = new Array();
    for (int64_t i = 0; i < size; i++) {
        arr->push(values[i]);
    }
    return arr;
}

extern "C" void* __simple_array_zeros(int64_t size) {
    if (size <= 0) {
        // Create empty array
        Array* arr = new Array();
        return arr;
    }
    // Create array filled with zeros
    Array* arr = new Array();
    for (int64_t i = 0; i < size; ++i) {
        arr->push(0.0);
    }
    return arr;
}

extern "C" void* __simple_array_ones(int64_t size) {
    // Create array filled with ones
    Array* arr = new Array();
    for (int64_t i = 0; i < size; ++i) {
        arr->push(1.0);
    }
    return arr;
}

extern "C" void __simple_array_push(void* array, double value) {
    std::cout << "[DEBUG] __simple_array_push called with array=" << array << ", value=" << value << std::endl;
    std::cout.flush();
    
    if (array) {
        std::cout << "[DEBUG] Pushing value to array" << std::endl;
        std::cout.flush();
        static_cast<Array*>(array)->push(value);
        std::cout << "[DEBUG] Value pushed successfully" << std::endl;
        std::cout.flush();
    } else {
        std::cout << "[DEBUG] ERROR: Array pointer is null!" << std::endl;
        std::cout.flush();
    }
}

extern "C" double __simple_array_pop(void* array) {
    if (array) {
        DynamicValue val = static_cast<Array*>(array)->pop();
        return val.to_number();
    }
    return 0.0;
}

extern "C" double __simple_array_get(void* array, int64_t index) {
    if (array) {
        DynamicValue val = (*static_cast<Array*>(array))[index];
        return val.to_number();
    }
    return 0.0;
}

extern "C" void __simple_array_set(void* array, int64_t index, double value) {
    if (array) {
        (*static_cast<Array*>(array))[index] = value;
    }
}

extern "C" int64_t __simple_array_length(void* array) {
    if (array) {
        return static_cast<int64_t>(static_cast<Array*>(array)->length());
    }
    return 0;
}

extern "C" double __simple_array_sum(void* array) {
    if (array) {
        return static_cast<Array*>(array)->sum();
    }
    return 0.0;
}

extern "C" double __simple_array_mean(void* array) {
    if (array) {
        return static_cast<Array*>(array)->mean();
    }
    return 0.0;
}

extern "C" void* __simple_array_shape(void* array) {
    if (array) {
        const std::vector<size_t>& shape = static_cast<Array*>(array)->shape();
        Array* result = new Array();
        for (size_t dim : shape) {
            result->push(static_cast<double>(dim));
        }
        return result;
    }
    return nullptr;
}

extern "C" const char* __simple_array_tostring(void* array) {
    if (array) {
        std::string str = static_cast<Array*>(array)->toString();
        return strdup(str.c_str());
    }
    return strdup("Array()");
}

extern "C" void* __simple_array_slice(void* array, int64_t start, int64_t end, int64_t step) {
    // Basic slice implementation for dynamic arrays
    if (array) {
        Array* src = static_cast<Array*>(array);
        Array* result = new Array();
        
        size_t size = src->size();
        int64_t actual_start = start < 0 ? size + start : start;
        int64_t actual_end = end < 0 ? size + end : end;
        
        actual_start = std::max(0L, std::min(actual_start, static_cast<int64_t>(size)));
        actual_end = std::max(0L, std::min(actual_end, static_cast<int64_t>(size)));
        
        for (int64_t i = actual_start; i < actual_end; i += step) {
            result->push((*src)[i]);
        }
        
        return result;
    }
    return nullptr;
}

extern "C" void* __simple_array_slice_all(void* array) {
    // Copy entire array
    if (array) {
        Array* src = static_cast<Array*>(array);
        Array* result = new Array();
        
        for (size_t i = 0; i < src->size(); ++i) {
            result->push((*src)[i]);
        }
        
        return result;
    }
    return nullptr;
}

double __simple_array_max(void* array) {
    if (array) {
        return static_cast<Array*>(array)->max();
    }
    return 0.0;
}

double __simple_array_min(void* array) {
    if (array) {
        return static_cast<Array*>(array)->min();
    }
    return 0.0;
}

// Helper function to get first dimension from shape array
int64_t __simple_array_get_first_dimension(void* shape_array) {
    if (shape_array) {
        Array* arr = static_cast<Array*>(shape_array);
        if (arr->length() > 0) {
            DynamicValue val = (*arr)[0];
            return static_cast<int64_t>(val.to_number());
        }
    }
    return 0;
}

// Array static factory methods - using DynamicArray for basic operations
void* __simple_array_arange(double start, double stop, double step) {
    // Create a basic arange implementation for dynamic arrays
    Array* arr = new Array();
    for (double val = start; val < stop; val += step) {
        arr->push(val);
    }
    return arr;
}

void* __simple_array_linspace(double start, double stop, int64_t num) {
    // Create a basic linspace implementation for dynamic arrays
    Array* arr = new Array();
    if (num <= 0) return arr;
    
    if (num == 1) {
        arr->push(start);
        return arr;
    }
    
    double step = (stop - start) / static_cast<double>(num - 1);
    for (int64_t i = 0; i < num; ++i) {
        arr->push(start + static_cast<double>(i) * step);
    }
    return arr;
    return arr;
}

// Timer management functions moved to goroutine_system.cpp

} // extern "C"

// Legacy function removed - use __lookup_function_fast(func_id) instead

// Thread-local storage for goroutine context
thread_local bool g_is_goroutine_context = false;

// Extern reference to global in goroutine_system.cpp
extern std::atomic<int64_t> g_active_goroutine_count;

extern "C" void __set_goroutine_context(int64_t is_goroutine) {
    bool was_goroutine = g_is_goroutine_context;
    g_is_goroutine_context = (is_goroutine != 0);
    
    if (g_is_goroutine_context && !was_goroutine) {
        // Setting up goroutine context
        // Increment active goroutine count
        g_active_goroutine_count.fetch_add(1);
    } else if (!g_is_goroutine_context && was_goroutine) {
        // Cleaning up goroutine context
        // Decrement active goroutine count
        g_active_goroutine_count.fetch_sub(1);
    }
}




// Ultra-High-Performance Direct Address Goroutine Spawn

void* __goroutine_spawn_func_ptr(void* func_ptr, void* arg) {
    
    // Cast function pointer to proper type and spawn goroutine directly
    // This is the FASTEST possible goroutine spawn - zero overhead, direct address call
    if (func_ptr) {
        // Use the goroutine scheduler to spawn with the function pointer
        typedef void (*func_t)();
        func_t function = reinterpret_cast<func_t>(func_ptr);
        
        std::function<void()> task = [function]() {
            function();
        };
        
        GoroutineScheduler::instance().spawn(task, nullptr);
    } else {
        std::cerr << "ERROR: __goroutine_spawn_func_ptr called with null function pointer" << std::endl;
    }
    
    return nullptr; // TODO: Return actual goroutine handle if needed
}

// Get the executable memory base address for relative offset calculations
extern "C" void* __get_executable_memory_base() {
    std::lock_guard<std::mutex> lock(g_executable_memory.mutex);
    return g_executable_memory.ptr;
}

// Timer system functions moved to goroutine_system.cpp

extern "C" const char* __dynamic_method_toString(void* obj) {
    // For now, we'll treat this as a simple array toString
    // In a full implementation, this would check object type and call appropriate toString
    if (obj) {
        Array* array = static_cast<Array*>(obj);
        std::string str = array->toString();
        return strdup(str.c_str());
    }
    return strdup("undefined");
}

// Typed Array implementation functions
extern "C" void* __typed_array_create_int32(int64_t initial_capacity) {
    std::vector<size_t> shape = {static_cast<size_t>(initial_capacity)};
    Int32Array* arr = new Int32Array(shape);
    return arr;
}

extern "C" void* __typed_array_create_int64(int64_t initial_capacity) {
    std::vector<size_t> shape = {static_cast<size_t>(initial_capacity)};
    Int64Array* arr = new Int64Array(shape);
    return arr;
}

extern "C" void* __typed_array_create_float32(int64_t initial_capacity) {
    std::vector<size_t> shape = {static_cast<size_t>(initial_capacity)};
    Float32Array* arr = new Float32Array(shape);
    return arr;
}

extern "C" void* __typed_array_create_float64(int64_t initial_capacity) {
    std::vector<size_t> shape = {static_cast<size_t>(initial_capacity)};
    Float64Array* arr = new Float64Array(shape);
    return arr;
}

extern "C" void* __typed_array_create_uint8(int64_t initial_capacity) {
    std::vector<size_t> shape = {static_cast<size_t>(initial_capacity)};
    Uint8Array* arr = new Uint8Array(shape);
    return arr;
}

extern "C" void* __typed_array_create_uint16(int64_t initial_capacity) {
    std::vector<size_t> shape = {static_cast<size_t>(initial_capacity)};
    Uint16Array* arr = new Uint16Array(shape);
    return arr;
}

extern "C" void* __typed_array_create_uint32(int64_t initial_capacity) {
    std::vector<size_t> shape = {static_cast<size_t>(initial_capacity)};
    Uint32Array* arr = new Uint32Array(shape);
    return arr;
}

extern "C" void* __typed_array_create_uint64(int64_t initial_capacity) {
    std::vector<size_t> shape = {static_cast<size_t>(initial_capacity)};
    Uint64Array* arr = new Uint64Array(shape);
    return arr;
}

// Typed Array push functions
extern "C" void __typed_array_push_int32(void* array, int32_t value) {
    if (array) {
        static_cast<Int32Array*>(array)->push(value);
    }
}

extern "C" void __typed_array_push_int64(void* array, int64_t value) {
    if (array) {
        static_cast<Int64Array*>(array)->push(value);
    }
}

extern "C" void __typed_array_push_float32(void* array, float value) {
    if (array) {
        static_cast<Float32Array*>(array)->push(value);
    }
}

extern "C" void __typed_array_push_float64(void* array, double value) {
    if (array) {
        static_cast<Float64Array*>(array)->push(value);
    }
}

extern "C" void __typed_array_push_uint8(void* array, uint8_t value) {
    if (array) {
        static_cast<Uint8Array*>(array)->push(value);
    }
}

extern "C" void __typed_array_push_uint16(void* array, uint16_t value) {
    if (array) {
        static_cast<Uint16Array*>(array)->push(value);
    }
}

extern "C" void __typed_array_push_uint32(void* array, uint32_t value) {
    if (array) {
        static_cast<Uint32Array*>(array)->push(value);
    }
}

extern "C" void __typed_array_push_uint64(void* array, uint64_t value) {
    if (array) {
        static_cast<Uint64Array*>(array)->push(value);
    }
}

// Array access functions
extern "C" int64_t __typed_array_size(void* array) {
    if (array) {
        // Assuming all typed arrays have the same base structure with size field
        return static_cast<Int32Array*>(array)->length();
    }
    return 0;
}

extern "C" int32_t __typed_array_get_int32(void* array, int64_t index) {
    if (array) {
        return (*static_cast<Int32Array*>(array))[index];
    }
    return 0;
}

extern "C" int64_t __typed_array_get_int64(void* array, int64_t index) {
    if (array) {
        return (*static_cast<Int64Array*>(array))[index];
    }
    return 0;
}

extern "C" float __typed_array_get_float32(void* array, int64_t index) {
    if (array) {
        return (*static_cast<Float32Array*>(array))[index];
    }
    return 0.0f;
}

extern "C" double __typed_array_get_float64(void* array, int64_t index) {
    if (array) {
        return (*static_cast<Float64Array*>(array))[index];
    }
    return 0.0;
}

extern "C" uint8_t __typed_array_get_uint8(void* array, int64_t index) {
    if (array) {
        return (*static_cast<Uint8Array*>(array))[index];
    }
    return 0;
}

extern "C" uint16_t __typed_array_get_uint16(void* array, int64_t index) {
    if (array) {
        return (*static_cast<Uint16Array*>(array))[index];
    }
    return 0;
}

extern "C" uint32_t __typed_array_get_uint32(void* array, int64_t index) {
    if (array) {
        return (*static_cast<Uint32Array*>(array))[index];
    }
    return 0;
}

extern "C" uint64_t __typed_array_get_uint64(void* array, int64_t index) {
    if (array) {
        return (*static_cast<Uint64Array*>(array))[index];
    }
    return 0;
}

// Sum function for typed arrays
extern "C" double __typed_array_sum_float64(void* array) {
    if (array) {
        Float64Array* typed_arr = static_cast<Float64Array*>(array);
        return typed_arr->sum();
    }
    return 0.0;
}

extern "C" int64_t __typed_array_sum_int64(void* array) {
    if (array) {
        Int64Array* typed_arr = static_cast<Int64Array*>(array);
        return static_cast<int64_t>(typed_arr->sum());
    }
    return 0;
}

// Enhanced Array.zeros function that supports dtype parameter
extern "C" void* __simple_array_zeros_typed(int64_t size, const char* dtype) {
    // Ultra-safe parameter validation
    std::cout << "[DEBUG] __simple_array_zeros_typed ENTRY" << std::endl;
    std::cout.flush();
    
    std::cout << "[DEBUG] Parameter validation: size=" << size << std::endl;
    std::cout.flush();
    
    // Check if dtype pointer is valid
    if (dtype == nullptr) {
        std::cout << "[DEBUG] dtype is NULL!" << std::endl;
        std::cout.flush();
        return __simple_array_zeros(size);
    }
    
    // Try to safely access first character
    std::cout << "[DEBUG] Checking dtype pointer safety..." << std::endl;
    std::cout.flush();
    
    char first_char = 'X';
    try {
        first_char = dtype[0];
        std::cout << "[DEBUG] First char of dtype: " << first_char << std::endl;
        std::cout.flush();
    } catch (...) {
        std::cout << "[DEBUG] CRASH: dtype pointer is invalid!" << std::endl;
        std::cout.flush();
        return __simple_array_zeros(size);
    }
    
    std::cout << "[DEBUG] Creating dtype string..." << std::endl;
    std::cout.flush();
    
    std::string dtype_str;
    try {
        dtype_str = std::string(dtype);
        std::cout << "[DEBUG] dtype_str = '" << dtype_str << "'" << std::endl;
        std::cout.flush();
    } catch (...) {
        std::cout << "[DEBUG] CRASH: Failed to create string from dtype!" << std::endl;
        std::cout.flush();
        return __simple_array_zeros(size);
    }

    
    if (dtype_str == "float64") {
        std::cout << "[DEBUG] Creating Float64Array" << std::endl;
        std::cout.flush();
        Float64Array* arr = new Float64Array();
        std::cout << "[DEBUG] Float64Array created, adding zeros" << std::endl;
        std::cout.flush();
        // Add zeros to the array
        for (int64_t i = 0; i < size; i++) {
            arr->push(0.0);
        }
        std::cout << "[DEBUG] Float64Array zeros added, returning" << std::endl;
        std::cout.flush();
        return arr;
    } else if (dtype_str == "int64") {
        std::cout << "[DEBUG] Creating Int64Array" << std::endl;
        std::cout.flush();
        Int64Array* arr = new Int64Array();
        std::cout << "[DEBUG] Int64Array created, adding zeros" << std::endl;
        std::cout.flush();
        // Add zeros to the array
        for (int64_t i = 0; i < size; i++) {
            arr->push(0);
        }
        std::cout << "[DEBUG] Int64Array zeros added, returning" << std::endl;
        std::cout.flush();
        return arr;
    } else if (dtype_str == "float32") {
        Float32Array* arr = new Float32Array();
        // Add zeros to the array
        for (int64_t i = 0; i < size; i++) {
            arr->push(0.0f);
        }
        return arr;
    } else if (dtype_str == "int32") {
        Int32Array* arr = new Int32Array();
        // Add zeros to the array
        for (int64_t i = 0; i < size; i++) {
            arr->push(0);
        }
        return arr;
    } else {
        // Unknown dtype, fallback to regular array
        return __simple_array_zeros(size);
    }
}

// Wrapper function that accepts void* for string (from __string_intern)
extern "C" void* __simple_array_zeros_typed_wrapper(int64_t size, void* dtype_ptr) {
    std::cout << "[DEBUG] __simple_array_zeros_typed_wrapper ENTRY with size=" << size << ", dtype_ptr=" << dtype_ptr << std::endl;
    std::cout.flush();
    
    if (dtype_ptr == nullptr) {
        std::cout << "[DEBUG] dtype_ptr is null, using regular zeros" << std::endl;
        std::cout.flush();
        return __simple_array_zeros(size);
    }
    
    // Cast void* to const char*
    const char* dtype = static_cast<const char*>(dtype_ptr);
    std::cout << "[DEBUG] Converted void* to const char*, calling main function" << std::endl;
    std::cout.flush();
    
    return __simple_array_zeros_typed(size, dtype);
}
    
    if (dtype_str == "float64") {
        std::cout << "[DEBUG] Creating Float64Array" << std::endl;
        std::cout.flush();
        Float64Array* arr = new Float64Array();
        std::cout << "[DEBUG] Float64Array created, adding zeros" << std::endl;
        std::cout.flush();
        // Add zeros to the array
        for (int64_t i = 0; i < size; i++) {
            arr->push(0.0);
        }
        std::cout << "[DEBUG] Float64Array zeros added, returning" << std::endl;
        std::cout.flush();
        return arr;
    } else if (dtype_str == "int64") {
        std::cout << "[DEBUG] Creating Int64Array" << std::endl;
        std::cout.flush();
        Int64Array* arr = new Int64Array();
        std::cout << "[DEBUG] Int64Array created, adding zeros" << std::endl;
        std::cout.flush();
        // Add zeros to the array
        for (int64_t i = 0; i < size; i++) {
            arr->push(0);
        }
        std::cout << "[DEBUG] Int64Array zeros added, returning" << std::endl;
        std::cout.flush();
        return arr;
    } else if (dtype_str == "float32") {
        Float32Array* arr = new Float32Array();
        // Add zeros to the array
        for (int64_t i = 0; i < size; i++) {
            arr->push(0.0f);
        }
        return arr;
    } else if (dtype_str == "int32") {
        Int32Array* arr = new Int32Array();
        // Add zeros to the array
        for (int64_t i = 0; i < size; i++) {
            arr->push(0);
        }
        return arr;
    } else {
        // Unknown dtype, fallback to regular array
        return __simple_array_zeros(size);
    }
}



// Wrapper function that accepts void* for string (from __string_intern)
extern "C" void* __simple_array_zeros_typed_wrapper(int64_t size, void* dtype_ptr) {
    std::cout << "[DEBUG] __simple_array_zeros_typed_wrapper ENTRY with size=" << size << ", dtype_ptr=" << dtype_ptr << std::endl;
    std::cout.flush();
    
    if (dtype_ptr == nullptr) {
        std::cout << "[DEBUG] dtype_ptr is null, using regular zeros" << std::endl;
        std::cout.flush();
        return __simple_array_zeros(size);
    }
    
    // Cast void* to const char*
    const char* dtype = static_cast<const char*>(dtype_ptr);
    std::cout << "[DEBUG] Converted void* to const char*, calling main function" << std::endl;
    std::cout.flush();
    
    return __simple_array_zeros_typed(size, dtype);
}
