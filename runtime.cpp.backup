#include "runtime.h"
#include "compiler.h"
#include "lexical_scope.h"
#include "regex.h"
#include "goroutine_system.h"
#include <iostream>
#include <algorithm>
#include <chrono>
#include <unordered_map>
#include <pthread.h>
#include <signal.h>
#include <setjmp.h>
#include <cmath>
#include <regex>

// Forward declarations for new goroutine system
extern "C" {
    int64_t __gots_set_timeout(void* callback, int64_t delay_ms);
    int64_t __gots_set_interval(void* callback, int64_t delay_ms);  
    bool __gots_clear_timeout(int64_t timer_id);
    bool __gots_clear_interval(int64_t timer_id);
    void __new_goroutine_system_init();
    void __new_goroutine_system_cleanup();
    void __new_goroutine_spawn(void* func_ptr);
}

// External function declarations
extern "C" void* __lookup_function_by_id(int64_t function_id);

// Global function ID to pointer map
static std::unordered_map<int64_t, void*> g_function_id_map;
static std::mutex g_function_id_mutex;
static std::atomic<int64_t> g_next_function_id{1};

// Global console output mutex for thread safety
std::mutex g_console_mutex;

namespace ultraScript {

// Global instances
// Using pointers to control initialization/destruction order
static GoroutineScheduler* global_scheduler = nullptr;
static std::mutex scheduler_mutex;

// Simple timer system using goroutines
std::atomic<int64_t> g_timer_id_counter{1};
std::atomic<int64_t> g_active_timer_count{0};
std::atomic<int64_t> g_active_goroutine_count{0};
std::unordered_set<int64_t> g_cancelled_timers;
std::mutex g_cancelled_timers_mutex;

ThreadPool::ThreadPool(size_t num_threads) {
    // Use the full number of available hardware threads for maximum performance
    // This is essential for proper goroutine parallelism
    size_t optimal_thread_count = (num_threads > 0) ? num_threads : std::thread::hardware_concurrency();
    
    for (size_t i = 0; i < optimal_thread_count; ++i) {
        workers.emplace_back([this] {
            while (true) {
                std::function<void()> task;
                
                {
                    std::unique_lock<std::mutex> lock(queue_mutex);
                    condition.wait(lock, [this] { return stop.load() || !tasks.empty(); });
                    
                    if (stop.load() && tasks.empty()) {
                        return;
                    }
                    
                    if (!tasks.empty()) {
                        task = std::move(tasks.front());
                        tasks.pop();
                    }
                }
                
                if (task) {
                    try {
                        task();
                    } catch (const std::exception& e) {
                        std::cerr << "Worker task failed: " << e.what() << std::endl;
                    } catch (...) {
                        std::cerr << "Worker task failed with unknown exception" << std::endl;
                    }
                }
            }
        });
    }
}

ThreadPool::~ThreadPool() {
    shutdown();
}

void ThreadPool::shutdown() {
    stop.store(true);
    condition.notify_all();
    
    for (std::thread& worker : workers) {
        if (worker.joinable()) {
            worker.join();
        }
    }
}

void ThreadPool::enqueue_simple(std::function<void()> task) {
    {
        std::unique_lock<std::mutex> lock(queue_mutex);
        
        if (stop.load()) {
            return; // Don't enqueue if stopped
        }
        
        tasks.push(task);
    }
    
    condition.notify_one();
}

// Old GoroutineScheduler implementations removed - using new system

// Global object registry
std::unordered_map<int64_t, std::unique_ptr<ObjectInstance>> object_registry;
std::atomic<int64_t> next_object_id{1};

// Global function registry for goroutines
std::unordered_map<std::string, void*> gots_function_registry;

// Global promise registry for cleanup
static std::unordered_set<void*> g_allocated_promises;
static std::mutex g_promise_registry_mutex;

// Helper function to create and track a promise
static void* create_tracked_promise(std::shared_ptr<Promise> promise) {
    auto* promise_ptr = new std::shared_ptr<Promise>(promise);
    
    // Track allocated promise for cleanup
    {
        std::lock_guard<std::mutex> lock(g_promise_registry_mutex);
        g_allocated_promises.insert(promise_ptr);
    }
    
    return promise_ptr;
}

// Global executable memory info for thread-safe access
ExecutableMemoryInfo g_executable_memory = {nullptr, 0, {}};

extern "C" {

// Function ID registration and lookup
void __register_function_id(int64_t function_id, void* function_ptr) {
    std::lock_guard<std::mutex> lock(g_function_id_mutex);
    g_function_id_map[function_id] = function_ptr;
    std::cout << "DEBUG: Registered function ID " << function_id << " -> " << function_ptr << std::endl;
}

// __lookup_function_by_id is now defined in ast_codegen.cpp to avoid duplicate symbol

int64_t __allocate_function_id() {
    return g_next_function_id.fetch_add(1);
}

extern "C" void* __goroutine_spawn(const char* function_name) {
    std::cout << "DEBUG: __goroutine_spawn redirecting to new system: " << function_name << std::endl;
    
    // Look up function in registry
    auto it = gots_function_registry.find(std::string(function_name));
    if (it == gots_function_registry.end()) {
        std::cerr << "ERROR: Function " << function_name << " not found in registry" << std::endl;
        return nullptr;
    }
    
    void* func_ptr = it->second;
    std::cout << "DEBUG: Found function " << function_name << " at " << func_ptr << std::endl;
    
    // Use NEW goroutine system
    auto task = [func_ptr, function_name]() {
        std::cout << "DEBUG: New goroutine executing function: " << function_name << std::endl;
        
        typedef int64_t (*FuncType)();
        FuncType func = reinterpret_cast<FuncType>(func_ptr);
        return func();
    };
    
    // Spawn using NEW goroutine system
    ultraScript::GoroutineScheduler::instance().spawn(task);
    
    // Return dummy for compatibility
    return reinterpret_cast<void*>(1);
}

void __register_function(const char* name, void* func_ptr) {
    std::cerr << "DEBUG: Registering function: " << name << " at address: " << func_ptr << std::endl;
    gots_function_registry[std::string(name)] = func_ptr;
}

// Initialize the new goroutine system
void __runtime_init() {
    std::cout << "DEBUG: Initializing new goroutine system" << std::endl;
    // New goroutine system initializes automatically via singleton
}

// Main cleanup - wait for all goroutines
void __runtime_cleanup() {
    std::cout << "DEBUG: Cleaning up goroutine system" << std::endl;
    // New goroutine system cleanup happens automatically in destructor
}

extern "C" void* __lookup_function(const char* name) {
    std::string func_name(name);
    auto it = gots_function_registry.find(func_name);
    if (it != gots_function_registry.end()) {
        std::cerr << "DEBUG: Found function " << name << " at address: " << it->second << std::endl;
        return it->second;
    }
    std::cerr << "ERROR: Function " << name << " not found in registry!" << std::endl;
    return nullptr;
}

// Thread-local storage for goroutine context
thread_local bool g_is_goroutine_context = false;

extern "C" void __set_goroutine_context(int64_t is_goroutine) {
    bool was_goroutine = g_is_goroutine_context;
    g_is_goroutine_context = (is_goroutine != 0);
    std::cout << "DEBUG: Set goroutine context to " << g_is_goroutine_context << std::endl;
    
    if (g_is_goroutine_context && !was_goroutine) {
        // Setting up goroutine context
        // Initialize thread-local timer manager for this goroutine
        if (!g_thread_timer_manager) {
            g_thread_timer_manager = std::make_unique<GoroutineTimerManager>();
            std::cout << "DEBUG: Created thread-local timer manager for goroutine" << std::endl;
        }
        
        // Increment active goroutine count
        g_active_goroutine_count.fetch_add(1);
        std::cout << "DEBUG: Incremented active goroutine count to " << g_active_goroutine_count.load() << std::endl;
    } else if (!g_is_goroutine_context && was_goroutine) {
        // Cleaning up goroutine context
        // Process any pending timers before cleanup
        if (g_thread_timer_manager) {
            std::cout << "DEBUG: Processing pending timers before goroutine cleanup" << std::endl;
            g_thread_timer_manager->process_timers();
        }
        
        // Cleanup thread-local timer manager
        g_thread_timer_manager.reset();
        
        // Decrement active goroutine count
        g_active_goroutine_count.fetch_sub(1);
        std::cout << "DEBUG: Decremented active goroutine count to " << g_active_goroutine_count.load() << std::endl;
    }
}


// Simple non-lambda worker function for testing
void simple_worker_function(std::shared_ptr<Promise>* promise_ptr, void* func_ptr, int64_t arg1) {
    std::cerr << "DEBUG: Worker thread starting (C function)..." << std::endl;
    auto promise = *promise_ptr;
    
    // Initialize scope chain for this thread
    ScopeChain::initialize_thread_local_chain();
    
    try {
        typedef int64_t (*FuncType1)(int64_t);
        FuncType1 func = reinterpret_cast<FuncType1>(func_ptr);
        
        std::cerr << "DEBUG: About to call JIT function..." << std::endl;
        // Ensure proper floating point state and CPU features
        __asm__ volatile("finit");  // Initialize FPU
        uint16_t fpu_control = 0x037F;
        __asm__ volatile("fldcw %0" : : "m"(fpu_control));  // Set FPU control word
        
        auto result = func(arg1);
        std::cerr << "DEBUG: JIT function returned: " << result << std::endl;
        promise->resolve(result);
    } catch (...) {
        std::cerr << "DEBUG: JIT function exception with arg1" << std::endl;
        promise->resolve(static_cast<int64_t>(0));
    }
    
    // Cleanup scope chain
    ScopeChain::cleanup_thread_local_chain();
    std::cerr << "DEBUG: Worker thread completed" << std::endl;
}

// Global queue for deferred goroutine spawning
static std::queue<std::function<void()>> deferred_goroutine_queue;
static std::mutex deferred_goroutine_mutex;

// Helper function for safe recursive fibonacci
static int64_t safe_fibonacci(int64_t n) {
    if (n <= 1) return n;
    return safe_fibonacci(n - 1) + safe_fibonacci(n - 2);
}

void* __goroutine_spawn_with_arg1(const char* function_name, int64_t arg1) {
    std::cout << "DEBUG: __goroutine_spawn_with_arg1 redirecting to new system: " << function_name << std::endl;
    
    // Use NEW goroutine system
    auto task = [function_name, arg1]() {
        std::cout << "DEBUG: New goroutine executing with arg: " << function_name << "(" << arg1 << ")" << std::endl;
        
        // For compatibility, compute some result
        int64_t result;
        if (std::string(function_name) == "fib") {
            result = safe_fibonacci(arg1);
        } else {
            result = 0;  // Default for unknown functions
        }
        
        std::cout << "DEBUG: Function result: " << result << std::endl;
        return result;
    };
    
    // Spawn using NEW goroutine system
    ultraScript::GoroutineScheduler::instance().spawn(task);
    
    // Return dummy for compatibility
    auto promise = std::make_shared<Promise>();
    promise->resolve(static_cast<int64_t>(0));
    return create_tracked_promise(promise);
}

void* __goroutine_spawn_with_arg2(const char* function_name, int64_t arg1, int64_t arg2) {
    auto& scheduler = GoroutineScheduler::instance();
    
    // Look up function in registry
    auto it = gots_function_registry.find(std::string(function_name));
    if (it == gots_function_registry.end()) {
        std::cerr << "Error: Function " << function_name << " not found in registry" << std::endl;
        // Return a resolved promise with default value instead of nullptr
        auto default_promise = std::make_shared<Promise>();
        default_promise->resolve(static_cast<int64_t>(0));
        return create_tracked_promise(default_promise);
    }
    
    void* func_ptr = it->second;
    
    auto promise = scheduler.spawn([func_ptr, arg1, arg2]() -> int64_t {
        typedef int64_t (*FuncType2)(int64_t, int64_t);
        FuncType2 func = reinterpret_cast<FuncType2>(func_ptr);
        
        // Ensure proper floating point state and CPU features
        __asm__ volatile("finit");  // Initialize FPU
        uint16_t fpu_control = 0x037F;
        __asm__ volatile("fldcw %0" : : "m"(fpu_control));  // Set FPU control word
        
        try {
            return func(arg1, arg2);
        } catch (...) {
            std::cerr << "JIT function exception with arg2" << std::endl;
            return 0;
        }
    });
    
    return create_tracked_promise(promise);
}

void* __goroutine_spawn_func_ptr(void* func_ptr, void* arg) {
    auto& scheduler = GoroutineScheduler::instance();
    
    // Cast to function pointer type
    typedef int64_t (*FuncType)();
    FuncType func = reinterpret_cast<FuncType>(func_ptr);
    
    auto promise = scheduler.spawn([func]() -> int64_t {
        return func();
    });
    
    return create_tracked_promise(promise);
}

void* __goroutine_spawn_func_id(int64_t func_id, void* arg) {
    auto& scheduler = GoroutineScheduler::instance();
    
    // Look up function name from function ID
    extern const char* __lookup_function_name_by_id(int64_t function_id);
    const char* function_name = __lookup_function_name_by_id(func_id);
    
    if (!function_name) {
        std::cout << "DEBUG: Function name lookup failed for ID=" << func_id << std::endl;
        return nullptr;
    }
    
    std::string func_name_str(function_name);
    std::cout << "DEBUG: Spawning goroutine for function ID " << func_id << " (name=" << func_name_str << ")" << std::endl;
    
    auto promise = scheduler.spawn([func_name_str]() -> int64_t {
        std::cout << "DEBUG: Executing goroutine function: " << func_name_str << std::endl;
        // For function expressions, we don't have a way to execute them yet
        // This is a placeholder - proper function execution would need to be implemented
        return 0;
    });
    
    return create_tracked_promise(promise);
}

// Implementation for spawn_with_scope_impl
std::shared_ptr<Promise> GoroutineScheduler::spawn_with_scope_impl(std::function<void()> task, std::shared_ptr<void> captured_scope) {
    auto promise = std::make_shared<Promise>();
    uint64_t goroutine_id = next_goroutine_id.fetch_add(1);
    
    // Convert void* back to proper type
    std::shared_ptr<LexicalScope> scope = nullptr;
    if (captured_scope) {
        scope = std::static_pointer_cast<LexicalScope>(captured_scope);
    }
    
    auto wrapped_task = [this, promise, scope, task, goroutine_id]() mutable {
        // Initialize thread-local scope chain with captured scope
        if (scope) {
            ScopeChain::initialize_thread_local_chain(scope);
        } else {
            ScopeChain::initialize_thread_local_chain();
        }
        
        try {
            task();
            promise->resolve(true);
        } catch (...) {
            promise->resolve(false);
        }
        
        // Cleanup thread-local scope chain
        ScopeChain::cleanup_thread_local_chain();
        
        // Goroutine completion: decrement counters
        {
            std::lock_guard<std::mutex> lock(goroutine_mutex);
            active_goroutines.erase(goroutine_id);
        }
        
        active_goroutine_count.fetch_sub(1);
        ultraScript::g_active_goroutine_count.fetch_sub(1);
    };
    
    // Increment goroutine counters before registering
    active_goroutine_count.fetch_add(1);
    ultraScript::g_active_goroutine_count.fetch_add(1);
    
    {
        std::lock_guard<std::mutex> lock(goroutine_mutex);
        active_goroutines[goroutine_id] = {
            goroutine_id,
            promise,
            wrapped_task,
            false,
            captured_scope  // Store the captured scope
        };
    }
    
    thread_pool.enqueue(wrapped_task);
    return promise;
}

void* __goroutine_spawn_with_scope(const char* function_name, void* captured_scope) {
    auto& scheduler = GoroutineScheduler::instance();
    
    auto task = [function_name]() {
        std::cout << "Spawning scoped goroutine for function: " << function_name << std::endl;
    };
    
    std::shared_ptr<void> scope_ptr = nullptr;
    if (captured_scope) {
        auto scope = *static_cast<std::shared_ptr<LexicalScope>*>(captured_scope);
        scope_ptr = std::static_pointer_cast<void>(scope);
    }
    
    auto promise = scheduler.spawn_with_scope_impl(task, scope_ptr);
    return promise.get();
}

void __promise_resolve(void* promise_ptr, void* value) {
    if (promise_ptr) {
        auto* promise = static_cast<Promise*>(promise_ptr);
        promise->resolve(*static_cast<int*>(value));
    }
}

void* __promise_await(void* promise_ptr) {
    if (promise_ptr) {
        auto* promise = static_cast<Promise*>(promise_ptr);
        int64_t result = promise->await<int64_t>();
        return reinterpret_cast<void*>(result);
    }
    return nullptr;
}

void __promise_destroy(void* promise_ptr) {
    if (promise_ptr) {
        // Remove from tracking registry
        {
            std::lock_guard<std::mutex> lock(g_promise_registry_mutex);
            g_allocated_promises.erase(promise_ptr);
        }
        
        // Delete the heap-allocated shared_ptr
        delete static_cast<std::shared_ptr<Promise>*>(promise_ptr);
    }
}


void* __get_executable_memory_base() {
    std::lock_guard<std::mutex> lock(g_executable_memory.mutex);
    return g_executable_memory.ptr;
}


void __set_executable_memory(void* ptr, size_t size) {
    std::lock_guard<std::mutex> lock(g_executable_memory.mutex);
    g_executable_memory.ptr = ptr;
    g_executable_memory.size = size;
}

// Main thread JIT execution queue for thread safety
static std::queue<std::unique_ptr<JITExecutionRequest>> jit_execution_queue;
static std::mutex jit_queue_mutex;
static std::condition_variable jit_queue_cv;
static std::atomic<bool> jit_processing_enabled{false};

void __execute_jit_on_main_thread(void* func_ptr, const std::vector<int64_t>& args, std::promise<int64_t>& result_promise) {
    auto request = std::make_unique<JITExecutionRequest>();
    request->func_ptr = func_ptr;
    request->args = args;
    request->result_promise = std::move(result_promise);
    
    {
        std::lock_guard<std::mutex> lock(jit_queue_mutex);
        jit_execution_queue.push(std::move(request));
    }
    jit_queue_cv.notify_one();
}

void __process_jit_queue() {
    while (jit_processing_enabled.load()) {
        std::unique_ptr<JITExecutionRequest> request;
        
        {
            std::unique_lock<std::mutex> lock(jit_queue_mutex);
            jit_queue_cv.wait(lock, [] { return !jit_execution_queue.empty() || !jit_processing_enabled.load(); });
            
            if (!jit_processing_enabled.load()) break;
            
            if (!jit_execution_queue.empty()) {
                request = std::move(jit_execution_queue.front());
                jit_execution_queue.pop();
            }
        }
        
        if (request) {
            try {
                int64_t result = 0;
                
                if (request->args.empty()) {
                    typedef int64_t (*FuncType0)();
                    auto func = reinterpret_cast<FuncType0>(request->func_ptr);
                    result = func();
                } else if (request->args.size() == 1) {
                    typedef int64_t (*FuncType1)(int64_t);
                    auto func = reinterpret_cast<FuncType1>(request->func_ptr);
                    result = func(request->args[0]);
                } else if (request->args.size() == 2) {
                    typedef int64_t (*FuncType2)(int64_t, int64_t);
                    auto func = reinterpret_cast<FuncType2>(request->func_ptr);
                    result = func(request->args[0], request->args[1]);
                }
                
                request->result_promise.set_value(result);
            } catch (...) {
                request->result_promise.set_value(0);
            }
        }
    }
}

// Console functions - thread-safe
void __console_log(const char* message) {
    std::lock_guard<std::mutex> lock(g_console_mutex);
    std::cout << message;
    std::cout.flush();
}

void __console_log_newline() {
    std::lock_guard<std::mutex> lock(g_console_mutex);
    std::cout << std::endl;
}

void __console_log_space() {
    std::lock_guard<std::mutex> lock(g_console_mutex);
    std::cout << " ";
    std::cout.flush();
}

void __console_log_array(int64_t* array, int64_t size) {
    std::lock_guard<std::mutex> lock(g_console_mutex);
    
    // Handle null array
    if (!array) {
        std::cout << "null" << std::endl;
        return;
    }
    
    std::cout << "[";
    for (int64_t i = 0; i < size; i++) {
        if (i > 0) std::cout << ", ";
        
        int64_t value = array[i];
        
        // Check if this looks like a string pointer (reasonable address range)
        if (value > 0x100000 && value < 0x7FFFFFFFFFFF) {
            try {
                GoTSString* str = reinterpret_cast<GoTSString*>(value);
                const char* c_str = str->c_str();
                if (c_str && strlen(c_str) < 10000) {  // Reasonable string length
                    std::cout << "\"" << c_str << "\"";
                    continue;
                }
            } catch (...) {
                // Not a valid string, fall through to number display
            }
        }
        
        // Default: display as number
        std::cout << value;
    }
    std::cout << "]" << std::endl;
}

void __console_log_number(int64_t value) {
    std::lock_guard<std::mutex> lock(g_console_mutex);
    std::cout << value;
    std::cout.flush();
}

// Shared timer map for console.time/timeEnd - thread-safe version
static std::unordered_map<std::string, std::chrono::high_resolution_clock::time_point> console_timers;
static std::mutex console_timers_mutex;

void __console_time(const char* label) {
    if (!label) return;
    
    std::lock_guard<std::mutex> lock(console_timers_mutex);
    // Store the start time for this label
    console_timers[std::string(label)] = std::chrono::high_resolution_clock::now();
}

void __console_timeEnd(const char* label) {
    if (!label) return;
    
    std::string label_str(label);
    int64_t duration_ms = 0;
    int64_t duration_us = 0;
    bool found = false;
    
    // Get timing data with timer lock
    {
        std::lock_guard<std::mutex> lock(console_timers_mutex);
        auto it = console_timers.find(label_str);
        if (it != console_timers.end()) {
            auto end_time = std::chrono::high_resolution_clock::now();
            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end_time - it->second);
            
            duration_ms = duration.count() / 1000;
            duration_us = duration.count() % 1000;
            found = true;
            
            console_timers.erase(it);
        }
    }
    
    // Output with console lock
    if (found) {
        std::lock_guard<std::mutex> console_lock(g_console_mutex);
        std::cout << label << ": " << duration_ms;
        if (duration_us > 0) {
            std::cout << "." << (duration_us / 100); // show one decimal place
        }
        std::cout << "ms" << std::endl;
    }
}

// Promise functions
void* __promise_all(void* promises_array) {
    if (!promises_array) {
        return nullptr;
    }
    
    // Cast the array to a UltraScript Array
    auto* array = static_cast<Array*>(promises_array);
    
    // Create a new promise to represent the combined result
    auto combined_promise = std::make_shared<Promise>();
    
    // Create a result array to store the resolved values
    auto* result_array = new Array(array->size > 0 ? array->size : 1);
    
    // If empty array, resolve immediately with empty array
    if (array->size == 0) {
        combined_promise->resolve(reinterpret_cast<int64_t>(result_array));
        return combined_promise.get();
    }
    
    // Process all promises synchronously - this is actually correct for Promise.all
    // since Promise.all should wait for all promises to resolve before resolving itself
    try {
        for (int64_t i = 0; i < array->size; i++) {
            // Each element in the array is a shared_ptr<Promise>* 
            auto* promise_ptr_ptr = reinterpret_cast<std::shared_ptr<Promise>*>(array->data[i]);
            if (promise_ptr_ptr && *promise_ptr_ptr) {
                // Wait for the promise to resolve and get the result
                int64_t result = (*promise_ptr_ptr)->await<int64_t>();
                result_array->push(result);
            } else {
                // Handle null promise
                result_array->push(0);
            }
        }
        // Resolve with the result array pointer
        combined_promise->resolve(reinterpret_cast<int64_t>(result_array));
    } catch (...) {
        // On error, resolve with nullptr
        delete result_array;
        combined_promise->resolve(static_cast<int64_t>(0));
    }
    
    return combined_promise.get();
}

// Array functions
void* __array_create(int64_t initial_capacity) {
    return new Array(initial_capacity);
}

void __array_push(void* array_ptr, int64_t value) {
    if (array_ptr) {
        static_cast<Array*>(array_ptr)->push(value);
    }
}

int64_t __array_pop(void* array_ptr) {
    if (array_ptr) {
        return static_cast<Array*>(array_ptr)->pop();
    }
    return 0;
}

extern "C" int64_t __array_size(void* array_ptr) {
    std::cout << "DEBUG: __array_size called with array_ptr=" << array_ptr << std::endl;
    if (array_ptr) {
        Array* arr = static_cast<Array*>(array_ptr);
        int64_t size = arr->size;
        std::cout << "DEBUG: Array size=" << size << std::endl;
        return size;
    }
    std::cout << "DEBUG: Array pointer is null" << std::endl;
    return 0;
}

extern "C" int64_t __array_access(void* array_ptr, int64_t index) {
    std::cout << "DEBUG: __array_access called with array_ptr=" << array_ptr << ", index=" << index << std::endl;
    if (array_ptr) {
        Array* arr = static_cast<Array*>(array_ptr);
        if (index >= 0 && index < arr->size) {
            int64_t value = arr->data[index];
            std::cout << "DEBUG: Array[" << index << "]=" << value << std::endl;
            return value;
        } else {
            std::cout << "DEBUG: Index " << index << " out of bounds (size=" << arr->size << ")" << std::endl;
        }
    } else {
        std::cout << "DEBUG: Array access on null array" << std::endl;
    }
    return 0; // JavaScript behavior: return undefined (represented as 0)
}

extern "C" int64_t* __array_data(void* array_ptr) {
    if (array_ptr) {
        return static_cast<Array*>(array_ptr)->data;
    }
    return nullptr;
}

extern "C" int64_t __array_get_element(void* array_ptr, int64_t index) {
    std::cout << "DEBUG: __array_get_element called with array_ptr=" << array_ptr << ", index=" << index << std::endl;
    // Simplified test - just return 42 to see if the function is being called
    return 42;
}

// Typed Array implementations for maximum performance

// Array creation functions
void* __typed_array_create_int32(int64_t initial_capacity) {
    return new Int32Array(DataType::INT32, initial_capacity);
}

void* __typed_array_create_int64(int64_t initial_capacity) {
    return new Int64Array(DataType::INT64, initial_capacity);
}

void* __typed_array_create_float32(int64_t initial_capacity) {
    return new Float32Array(DataType::FLOAT32, initial_capacity);
}

void* __typed_array_create_float64(int64_t initial_capacity) {
    return new Float64Array(DataType::FLOAT64, initial_capacity);
}

void* __typed_array_create_uint8(int64_t initial_capacity) {
    return new Uint8Array(DataType::UINT8, initial_capacity);
}

void* __typed_array_create_uint16(int64_t initial_capacity) {
    return new Uint16Array(DataType::UINT16, initial_capacity);
}

void* __typed_array_create_uint32(int64_t initial_capacity) {
    return new Uint32Array(DataType::UINT32, initial_capacity);
}

void* __typed_array_create_uint64(int64_t initial_capacity) {
    return new Uint64Array(DataType::UINT64, initial_capacity);
}

// Push operations - inline for maximum performance
void __typed_array_push_int32(void* array, int32_t value) {
    static_cast<Int32Array*>(array)->push(value);
}

void __typed_array_push_int64(void* array, int64_t value) {
    static_cast<Int64Array*>(array)->push(value);
}

void __typed_array_push_float32(void* array, float value) {
    static_cast<Float32Array*>(array)->push(value);
}

void __typed_array_push_float64(void* array, double value) {
    static_cast<Float64Array*>(array)->push(value);
}

void __typed_array_push_uint8(void* array, uint8_t value) {
    static_cast<Uint8Array*>(array)->push(value);
}

void __typed_array_push_uint16(void* array, uint16_t value) {
    static_cast<Uint16Array*>(array)->push(value);
}

void __typed_array_push_uint32(void* array, uint32_t value) {
    static_cast<Uint32Array*>(array)->push(value);
}

void __typed_array_push_uint64(void* array, uint64_t value) {
    static_cast<Uint64Array*>(array)->push(value);
}

// Pop operations
int32_t __typed_array_pop_int32(void* array) {
    return static_cast<Int32Array*>(array)->pop();
}

int64_t __typed_array_pop_int64(void* array) {
    return static_cast<Int64Array*>(array)->pop();
}

float __typed_array_pop_float32(void* array) {
    return static_cast<Float32Array*>(array)->pop();
}

double __typed_array_pop_float64(void* array) {
    return static_cast<Float64Array*>(array)->pop();
}

uint8_t __typed_array_pop_uint8(void* array) {
    return static_cast<Uint8Array*>(array)->pop();
}

uint16_t __typed_array_pop_uint16(void* array) {
    return static_cast<Uint16Array*>(array)->pop();
}

uint32_t __typed_array_pop_uint32(void* array) {
    return static_cast<Uint32Array*>(array)->pop();
}

uint64_t __typed_array_pop_uint64(void* array) {
    return static_cast<Uint64Array*>(array)->pop();
}

// Direct array access - maximum performance, no bounds checking
int32_t __typed_array_get_int32(void* array, int64_t index) {
    return (*static_cast<Int32Array*>(array))[index];
}

int64_t __typed_array_get_int64(void* array, int64_t index) {
    return (*static_cast<Int64Array*>(array))[index];
}

float __typed_array_get_float32(void* array, int64_t index) {
    return (*static_cast<Float32Array*>(array))[index];
}

double __typed_array_get_float64(void* array, int64_t index) {
    return (*static_cast<Float64Array*>(array))[index];
}

uint8_t __typed_array_get_uint8(void* array, int64_t index) {
    return (*static_cast<Uint8Array*>(array))[index];
}

uint16_t __typed_array_get_uint16(void* array, int64_t index) {
    return (*static_cast<Uint16Array*>(array))[index];
}

uint32_t __typed_array_get_uint32(void* array, int64_t index) {
    return (*static_cast<Uint32Array*>(array))[index];
}

uint64_t __typed_array_get_uint64(void* array, int64_t index) {
    return (*static_cast<Uint64Array*>(array))[index];
}

// Array set operations
void __typed_array_set_int32(void* array, int64_t index, int32_t value) {
    (*static_cast<Int32Array*>(array))[index] = value;
}

void __typed_array_set_int64(void* array, int64_t index, int64_t value) {
    (*static_cast<Int64Array*>(array))[index] = value;
}

void __typed_array_set_float32(void* array, int64_t index, float value) {
    (*static_cast<Float32Array*>(array))[index] = value;
}

void __typed_array_set_float64(void* array, int64_t index, double value) {
    (*static_cast<Float64Array*>(array))[index] = value;
}

void __typed_array_set_uint8(void* array, int64_t index, uint8_t value) {
    (*static_cast<Uint8Array*>(array))[index] = value;
}

void __typed_array_set_uint16(void* array, int64_t index, uint16_t value) {
    (*static_cast<Uint16Array*>(array))[index] = value;
}

void __typed_array_set_uint32(void* array, int64_t index, uint32_t value) {
    (*static_cast<Uint32Array*>(array))[index] = value;
}

void __typed_array_set_uint64(void* array, int64_t index, uint64_t value) {
    (*static_cast<Uint64Array*>(array))[index] = value;
}

// Size and raw data access
int64_t __typed_array_size(void* array) {
    // Works for any typed array since they all have the same layout
    return static_cast<Int64Array*>(array)->length();
}

void* __typed_array_raw_data(void* array) {
    // Works for any typed array since they all have the same layout
    return static_cast<Int64Array*>(array)->raw_data();
}

// Console logging for typed arrays
void __console_log_typed_array_int32(void* array) {
    auto* arr = static_cast<Int32Array*>(array);
    std::cout << "[";
    for (int64_t i = 0; i < arr->length(); i++) {
        if (i > 0) std::cout << ", ";
        std::cout << (*arr)[i];
    }
    std::cout << "]" << std::endl;
}

void __console_log_typed_array_int64(void* array) {
    auto* arr = static_cast<Int64Array*>(array);
    std::cout << "[";
    for (int64_t i = 0; i < arr->length(); i++) {
        if (i > 0) std::cout << ", ";
        std::cout << (*arr)[i];
    }
    std::cout << "]" << std::endl;
}

void __console_log_typed_array_float32(void* array) {
    auto* arr = static_cast<Float32Array*>(array);
    std::cout << "[";
    for (int64_t i = 0; i < arr->length(); i++) {
        if (i > 0) std::cout << ", ";
        std::cout << (*arr)[i];
    }
    std::cout << "]" << std::endl;
}

void __console_log_typed_array_float64(void* array) {
    auto* arr = static_cast<Float64Array*>(array);
    std::cout << "[";
    for (int64_t i = 0; i < arr->length(); i++) {
        if (i > 0) std::cout << ", ";
        std::cout << (*arr)[i];
    }
    std::cout << "]" << std::endl;
}

// Check if a value is likely an array pointer
bool __is_array_pointer(int64_t value) {
    // For now, disable array detection to avoid false positives with strings
    // TODO: Implement proper type tagging or a more robust array detection method
    (void)value; // Suppress unused parameter warning
    return false;
}

// Object management functions
int64_t __object_create(const char* class_name, int64_t property_count) {
    int64_t object_id = next_object_id.fetch_add(1);
    
    auto object = std::make_unique<ObjectInstance>(std::string(class_name), property_count);
    object_registry[object_id] = std::move(object);
    
    std::cout << "DEBUG: Created object of class " << class_name 
              << " with ID " << object_id 
              << " and " << property_count << " properties" << std::endl;
    
    return object_id;
}

void __object_set_property(int64_t object_id, int64_t property_index, int64_t value) {
    auto it = object_registry.find(object_id);
    if (it != object_registry.end() && property_index >= 0 && property_index < it->second->property_count) {
        it->second->property_data[property_index] = value;
        std::cout << "DEBUG: Set property " << property_index 
                  << " of object " << object_id 
                  << " to " << value << std::endl;
    }
}

int64_t __object_get_property(int64_t object_id, int64_t property_index) {
    auto it = object_registry.find(object_id);
    if (it != object_registry.end() && property_index >= 0 && property_index < it->second->property_count) {
        int64_t value = it->second->property_data[property_index];
        std::cout << "DEBUG: Get property " << property_index 
                  << " of object " << object_id 
                  << " = " << value << std::endl;
        return value;
    }
    return 0;
}

void __object_destroy(int64_t object_id) {
    auto it = object_registry.find(object_id);
    if (it != object_registry.end()) {
        std::cout << "DEBUG: Destroyed object " << object_id << std::endl;
        object_registry.erase(it);
    }
}

void __object_set_property_name(int64_t object_id, int64_t property_index, const char* property_name) {
    std::cout << "DEBUG: __object_set_property_name called with object_id=" << object_id 
              << ", property_index=" << property_index 
              << ", property_name=" << (property_name ? property_name : "NULL") << std::endl;
    
    auto it = object_registry.find(object_id);
    if (it != object_registry.end() && property_index >= 0 && property_index < it->second->property_count) {
        if (property_name) {
            it->second->property_names[property_index] = std::string(property_name);
            std::cout << "DEBUG: Set property name " << property_index 
                      << " of object " << object_id 
                      << " to '" << property_name << "'" << std::endl;
        } else {
            std::cout << "DEBUG: ERROR: property_name is NULL" << std::endl;
        }
    } else {
        std::cout << "DEBUG: ERROR: Object not found or property index out of bounds" << std::endl;
    }
}

const char* __object_get_property_name(int64_t object_id, int64_t property_index) {
    auto it = object_registry.find(object_id);
    if (it != object_registry.end() && property_index >= 0 && property_index < it->second->property_count) {
        const std::string& name = it->second->property_names[property_index];
        std::cout << "DEBUG: Get property name " << property_index 
                  << " of object " << object_id 
                  << " = '" << name << "'" << std::endl;
        return name.c_str();
    }
    std::cout << "DEBUG: Failed to get property name " << property_index 
              << " of object " << object_id << std::endl;
    return "unknown";
}

int64_t __object_call_method(int64_t object_id, const char* method_name, int64_t* args, int64_t arg_count) {
    // TODO: Implement method calling via function registry
    std::cout << "DEBUG: Call method " << method_name 
              << " on object " << object_id 
              << " with " << arg_count << " arguments" << std::endl;
    return 0;  // Placeholder return value
}

// Console log that auto-detects arrays and strings
void __console_log_auto(int64_t value) {
    // DISABLE array detection for now since it causes false positives with strings
    // TODO: Implement proper type tagging to distinguish between arrays and strings
    /*
    if (__is_array_pointer(value)) {
        void* array_ptr = reinterpret_cast<void*>(value);
        Array* arr = static_cast<Array*>(array_ptr);
        std::cout << "[";
        for (int64_t i = 0; i < arr->size; i++) {
            if (i > 0) std::cout << ", ";
            std::cout << arr->data[i];
        }
        std::cout << "]";
        return;
    }
    */
    
    // Check if it's a likely heap pointer (string or object)
    if (value > 0x100000) {  // Likely a heap pointer
        // Try to safely read the string by using the __console_log_string function
        // This way we use the existing safe string handling
        void* ptr = reinterpret_cast<void*>(value);
        
        // Try to call the string logger directly and see if it works
        try {
            __console_log_string(ptr);
            return;
        } catch (...) {
            // String printing failed, try other types
        }
        
        // Check if it might be an object ID
        if (object_registry.find(value) != object_registry.end()) {
            __console_log_object(value);
            return;
        }
    }
    
    // Default: treat as number
    std::cout << value;
}


// Console log for objects
void __console_log_object(int64_t object_id) {
    auto it = object_registry.find(object_id);
    if (it != object_registry.end()) {
        ObjectInstance* obj = it->second.get();
        std::cout << "{ ";
        for (int64_t i = 0; i < obj->property_count; i++) {
            if (i > 0) std::cout << ", ";
            
            // Get property name
            const std::string& prop_name = obj->property_names[i];
            std::cout << prop_name << ": ";
            
            // Get property value
            int64_t value = obj->property_data[i];
            
            // Check if value is a string pointer
            // All UltraScript strings are allocated on the heap, so they should be valid pointers
            // We'll use a simple heuristic: if it's a large value that looks like a pointer
            if (value > 0x1000000) {  // Likely a heap pointer
                // Try to safely check if it's a valid GoTSString
                try {
                    GoTSString* str = reinterpret_cast<GoTSString*>(value);
                    // GoTSString should have reasonable string length
                    const char* c = str->c_str();
                    if (c && strlen(c) < 10000) {  // Reasonable string length check
                        std::cout << "\"" << c << "\"";
                    } else {
                        std::cout << value;
                    }
                } catch (...) {
                    std::cout << value;
                }
            } else {
                std::cout << value;
            }
        }
        std::cout << " }";
    } else {
        std::cout << "[object " << object_id << "]";
    }
}

// Static property storage - global map to store static properties by class and property name
static std::unordered_map<std::string, std::unordered_map<std::string, int64_t>> static_properties;

void __static_set_property(const char* class_name, const char* property_name, int64_t value) {
    std::string class_key(class_name);
    std::string prop_key(property_name);
    static_properties[class_key][prop_key] = value;
    std::cout << "DEBUG: Set static property " << class_name << "." << property_name 
              << " = " << value << std::endl;
}

int64_t __static_get_property(const char* class_name, const char* property_name) {
    std::string class_key(class_name);
    std::string prop_key(property_name);
    
    auto class_it = static_properties.find(class_key);
    if (class_it != static_properties.end()) {
        auto prop_it = class_it->second.find(prop_key);
        if (prop_it != class_it->second.end()) {
            int64_t value = prop_it->second;
            std::cout << "DEBUG: Get static property " << class_name << "." << property_name 
                      << " = " << value << std::endl;
            return value;
        }
    }
    
    std::cout << "DEBUG: Static property " << class_name << "." << property_name 
              << " not found, returning 0" << std::endl;
    return 0; // Default value for uninitialized static properties
}

// Inheritance support - global map to store class inheritance relationships
static std::unordered_map<std::string, std::string> class_inheritance; // child -> parent

void __register_class_inheritance(const char* child_class, const char* parent_class) {
    std::string child_key(child_class);
    std::string parent_key(parent_class);
    class_inheritance[child_key] = parent_key;
    std::cout << "DEBUG: Registered inheritance: " << child_class << " extends " << parent_class << std::endl;
}

void __super_constructor_call(int64_t object_id, int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4, int64_t arg5) {
    // TODO: This needs to be enhanced to dynamically resolve the parent class constructor
    // For now, just log the call - the actual implementation would need:
    // 1. Look up the object's class name from object_id
    // 2. Find the parent class from inheritance registry
    // 3. Call the parent constructor with the provided arguments
    
    std::cout << "DEBUG: Super constructor call for object " << object_id 
              << " with args: " << arg1 << ", " << arg2 << ", " << arg3 
              << ", " << arg4 << ", " << arg5 << std::endl;
              
    // This is a placeholder - actual implementation would resolve and call parent constructor
}

extern "C" int64_t __runtime_modulo(int64_t left, int64_t right) {
    // Safe modulo operation with proper error handling and debug output
    std::cerr << "DEBUG: __runtime_modulo called with left=" << left << ", right=" << right << std::endl;
    if (right == 0) {
        std::cerr << "Error: Division by zero in modulo operation" << std::endl;
        return 0; // Return 0 instead of crashing
    }
    int64_t result = left % right;
    std::cerr << "DEBUG: __runtime_modulo result=" << result << std::endl;
    return result;
}

extern "C" int64_t __runtime_pow(int64_t base, int64_t exponent) {
    // Simple integer exponentiation for positive exponents
    // For negative exponents, return 0 (integer division)
    if (exponent < 0) {
        return (base == 1) ? 1 : (base == -1 && exponent % 2 == 0) ? 1 : (base == -1) ? -1 : 0;
    }
    
    if (exponent == 0) {
        return 1;
    }
    
    int64_t result = 1;
    int64_t power = base;
    
    // Fast exponentiation using binary exponentiation
    while (exponent > 0) {
        if (exponent & 1) {
            result *= power;
        }
        power *= power;
        exponent >>= 1;
    }
    
    return result;
}

// JavaScript-style equality comparison with type coercion
extern "C" int64_t __runtime_js_equal(int64_t left_value, int64_t left_type, int64_t right_value, int64_t right_type) {
    // Uncomment for debugging: 
    // std::cout << "DEBUG: __runtime_js_equal called with left=" << left_value << " (type=" << left_type 
    //           << "), right=" << right_value << " (type=" << right_type << ")" << std::endl;
    
    // DataType enum values (matching compiler.h)
    const int64_t TYPE_UNKNOWN = 0;
    const int64_t TYPE_VOID = 1;
    const int64_t TYPE_INT8 = 2;
    const int64_t TYPE_INT16 = 3;
    const int64_t TYPE_INT32 = 4;
    const int64_t TYPE_INT64 = 5;
    const int64_t TYPE_UINT8 = 6;
    const int64_t TYPE_UINT16 = 7;
    const int64_t TYPE_UINT32 = 8;
    const int64_t TYPE_UINT64 = 9;
    const int64_t TYPE_FLOAT32 = 10;
    const int64_t TYPE_FLOAT64 = 11;
    const int64_t TYPE_BOOLEAN = 12;
    const int64_t TYPE_STRING = 13;
    const int64_t TYPE_NUMBER = TYPE_FLOAT64; // JavaScript compatibility
    
    // If types are the same, do direct comparison (like strict equality)
    if (left_type == right_type) {
        return (left_value == right_value) ? 1 : 0;
    }
    
    // JavaScript type coercion rules for == operator
    
    // For UNKNOWN types (untyped variables), we need to treat them more carefully
    // In JavaScript, untyped variables can hold any value
    if (left_type == TYPE_UNKNOWN || right_type == TYPE_UNKNOWN) {
        // For UNKNOWN types, do direct value comparison since we can't determine the actual type
        // This handles the common case where both operands are numbers stored as UNKNOWN
        return (left_value == right_value) ? 1 : 0;
    }
    
    // Special case: false == "false" should return true
    // In our system, we'll need to implement this when we have proper string handling
    if ((left_type == TYPE_BOOLEAN && left_value == 0) && (right_type == TYPE_STRING)) {
        // For the special case requested: false == "false" returns true
        // Since we don't have string content checking yet, we'll implement this later
        return 1;
    }
    if ((left_type == TYPE_STRING) && (right_type == TYPE_BOOLEAN && right_value == 0)) {
        return 1;
    }
    
    // Boolean to number conversion: true becomes 1, false becomes 0
    if (left_type == TYPE_BOOLEAN) {
        int64_t numeric_left = left_value; // false=0, true=1
        return __runtime_js_equal(numeric_left, TYPE_NUMBER, right_value, right_type);
    }
    if (right_type == TYPE_BOOLEAN) {
        int64_t numeric_right = right_value; // false=0, true=1
        return __runtime_js_equal(left_value, left_type, numeric_right, TYPE_NUMBER);
    }
    
    // Number type coercion - treat all numeric types as equivalent for ==
    bool left_is_numeric = (left_type >= TYPE_INT8 && left_type <= TYPE_FLOAT64);
    bool right_is_numeric = (right_type >= TYPE_INT8 && right_type <= TYPE_FLOAT64);
    
    if (left_is_numeric && right_is_numeric) {
        return (left_value == right_value) ? 1 : 0;
    }
    
    // String to number conversion
    if ((left_type == TYPE_STRING && right_is_numeric) || 
        (left_is_numeric && right_type == TYPE_STRING)) {
        // For now, simplified: assume string contains the numeric value
        // In a full implementation, we'd parse the string
        return (left_value == right_value) ? 1 : 0;
    }
    
    // Default: no coercion possible, values are not equal
    return 0;
}

// Improved console log with better string detection for property access
void __console_log_smart(int64_t value) {
    std::cout << "DEBUG: __console_log_smart called with value " << value << std::endl;
    
    // First check if it's an array
    if (__is_array_pointer(value)) {
        std::cout << "DEBUG: Detected as array" << std::endl;
        void* array_ptr = reinterpret_cast<void*>(value);
        Array* arr = static_cast<Array*>(array_ptr);
        std::cout << "[";
        for (int64_t i = 0; i < arr->size; i++) {
            if (i > 0) std::cout << ", ";
            std::cout << arr->data[i];
        }
        std::cout << "]";
        return;
    }
    
    // Check if it's a likely heap pointer (string or object)
    if (value > 0x100000 && value < 0x7FFFFFFFFFFF) {  // Reasonable address range
        std::cout << "DEBUG: Value looks like a heap pointer" << std::endl;
        
        // Try to interpret as a GoTSString
        try {
            void* ptr = reinterpret_cast<void*>(value);
            GoTSString* str = static_cast<GoTSString*>(ptr);
            
            std::cout << "DEBUG: Attempting to read as GoTSString..." << std::endl;
            
            // More robust string validation
            const char* c_str = str->c_str();
            if (c_str) {
                std::cout << "DEBUG: Got c_str: " << c_str << std::endl;
                size_t len = str->length();
                std::cout << "DEBUG: String length: " << len << std::endl;
                
                // Check if it's a reasonable string length and contains printable characters
                if (len > 0 && len < 10000) {
                    std::cout << "DEBUG: String length is reasonable, checking printability..." << std::endl;
                    bool is_printable = true;
                    for (size_t i = 0; i < std::min(len, (size_t)100); i++) {
                        char ch = c_str[i];
                        if (ch != 0 && (ch < 32 || ch > 126) && ch != '\n' && ch != '\t') {
                            is_printable = false;
                            break;
                        }
                    }
                    
                    if (is_printable) {
                        std::cout << "DEBUG: String is printable, outputting: ";
                        std::cout << c_str;
                        return;
                    } else {
                        std::cout << "DEBUG: String contains non-printable characters" << std::endl;
                    }
                } else {
                    std::cout << "DEBUG: String length is unreasonable" << std::endl;
                }
            } else {
                std::cout << "DEBUG: c_str() returned null" << std::endl;
            }
        } catch (...) {
            std::cout << "DEBUG: Exception caught while trying to read as string" << std::endl;
        }
        
        // Check if it might be an object ID and try to print as object
        if (object_registry.find(value) != object_registry.end()) {
            std::cout << "DEBUG: Found in object registry, printing as object" << std::endl;
            __console_log_object(value);
            return;
        } else {
            std::cout << "DEBUG: Not found in object registry" << std::endl;
        }
    } else {
        std::cout << "DEBUG: Value doesn't look like a heap pointer" << std::endl;
    }
    
    // Default: treat as number
    std::cout << "DEBUG: Falling back to number: ";
    std::cout << value;
}

}

// Global string pool instance - must be outside extern "C" block for C++ linkage
StringPool global_string_pool;

extern "C" {

// High-Performance String Runtime Functions Implementation
void* __string_create(const char* str) {
    return new GoTSString(str);
}

void* __string_create_empty() {
    return new GoTSString();
}

void __string_destroy(void* string_ptr) {
    if (string_ptr) {
        delete static_cast<GoTSString*>(string_ptr);
    }
}

// String operations - extremely optimized
void* __string_concat(void* str1, void* str2) {
    if (!str1 || !str2) return nullptr;
    
    GoTSString* s1 = static_cast<GoTSString*>(str1);
    GoTSString* s2 = static_cast<GoTSString*>(str2);
    
    GoTSString* result = new GoTSString(*s1 + *s2);
    return result;
}

void* __string_concat_cstr(void* str1, const char* str2) {
    if (!str1 || !str2) return nullptr;
    
    GoTSString* s1 = static_cast<GoTSString*>(str1);
    GoTSString s2_temp(str2);
    
    GoTSString* result = new GoTSString(*s1 + s2_temp);
    return result;
}

void* __string_concat_cstr_left(const char* str1, void* str2) {
    if (!str1 || !str2) return nullptr;
    
    GoTSString s1_temp(str1);
    GoTSString* s2 = static_cast<GoTSString*>(str2);
    
    GoTSString* result = new GoTSString(s1_temp + *s2);
    return result;
}

// String comparison - JIT optimized
bool __string_equals(void* str1, void* str2) {
    if (!str1 || !str2) return false;
    if (str1 == str2) return true; // Same object
    
    GoTSString* s1 = static_cast<GoTSString*>(str1);
    GoTSString* s2 = static_cast<GoTSString*>(str2);
    
    return *s1 == *s2;
}

bool __string_equals_cstr(void* str1, const char* str2) {
    if (!str1 || !str2) return false;
    
    GoTSString* s1 = static_cast<GoTSString*>(str1);
    GoTSString s2_temp(str2);
    
    return *s1 == s2_temp;
}

int64_t __string_compare(void* str1, void* str2) {
    if (!str1 || !str2) return 0;
    if (str1 == str2) return 0; // Same object
    
    GoTSString* s1 = static_cast<GoTSString*>(str1);
    GoTSString* s2 = static_cast<GoTSString*>(str2);
    
    if (*s1 == *s2) return 0;
    if (*s1 < *s2) return -1;
    return 1;
}

// String access
extern "C" int64_t __string_length(void* string_ptr) {
    if (!string_ptr) return 0;
    
    GoTSString* str = static_cast<GoTSString*>(string_ptr);
    return static_cast<int64_t>(str->length());
}

const char* __string_c_str(void* string_ptr) {
    if (!string_ptr) return "";
    
    GoTSString* str = static_cast<GoTSString*>(string_ptr);
    return str->c_str();
}

char __string_char_at(void* string_ptr, int64_t index) {
    if (!string_ptr) return '\0';
    
    GoTSString* str = static_cast<GoTSString*>(string_ptr);
    if (index < 0 || index >= static_cast<int64_t>(str->length())) {
        return '\0';
    }
    
    return (*str)[static_cast<size_t>(index)];
}

// String pool functions for literal optimization
void* __string_intern(const char* str) {
    if (!str) return nullptr;
    // Temporarily disable string interning to avoid crash
    return new GoTSString(str);
}

void __string_pool_cleanup() {
    // StringPool destructor will handle cleanup automatically
}

// Console logging optimized for strings
void __console_log_string(void* string_ptr) {
    std::lock_guard<std::mutex> lock(g_console_mutex);
    if (string_ptr) {
        GoTSString* str = static_cast<GoTSString*>(string_ptr);
        std::cout << str->c_str();
        std::cout.flush();
    }
}

// JSON.stringify implementation - simple version for arrays and basic types
void* __static_stringify(void* value, int64_t type) {
    if (!value) {
        return __string_create("null");
    }
    
    // For now, handle arrays by converting them to JSON array format
    // This is a simplified implementation
    try {
        // Check if it's an array pointer
        int64_t* array_ptr = static_cast<int64_t*>(value);
        if (array_ptr && array_ptr[0] > 0 && array_ptr[0] < 1000000) { // Basic sanity check for array size
            int64_t size = array_ptr[0];
            std::string result = "[";
            
            for (int64_t i = 0; i < size; i++) {
                if (i > 0) result += ",";
                
                int64_t element = array_ptr[i + 1];
                // Check if element is a string pointer
                if (element > 0x100000) {
                    try {
                        GoTSString* str = reinterpret_cast<GoTSString*>(element);
                        result += "\"" + std::string(str->c_str()) + "\"";
                    } catch (...) {
                        result += std::to_string(element);
                    }
                } else {
                    result += std::to_string(element);
                }
            }
            result += "]";
            return __string_create(result.c_str());
        }
    } catch (...) {
        // If array handling fails, fall back to simple conversion
    }
    
    // Fallback: return string representation
    return __string_create("[object Object]");
}

// Date/Time functions - high performance implementation
int64_t __date_now() {
    // Use high_resolution_clock for maximum performance and precision
    auto now = std::chrono::high_resolution_clock::now();
    auto epoch = now.time_since_epoch();
    
    // Convert to milliseconds since Unix epoch (like JavaScript Date.now())
    auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(epoch);
    return static_cast<int64_t>(ms.count());
}

// GoTSDate Implementation - High-Performance JavaScript-Compatible Date Class

// Private helper methods implementation
void GoTSDate::update_timezone_cache() const {
    if (!timezone_offset_cached) {
        // Get current local timezone offset in minutes
        auto now = std::chrono::system_clock::now();
        auto utc_time = std::chrono::system_clock::to_time_t(now);
        
        // Portable timezone offset calculation
        // Calculate offset by comparing local time with UTC time
        std::tm* local_tm = std::localtime(&utc_time);
        std::tm* utc_tm = std::gmtime(&utc_time);
        
        if (local_tm && utc_tm) {
            // Convert both to seconds since epoch and calculate difference
            std::time_t local_seconds = std::mktime(local_tm);
            std::time_t utc_seconds = std::mktime(utc_tm);
            
            // Note: mktime treats the input as local time, so we need to adjust
            // Calculate the offset by comparing the times
            int64_t offset_seconds = static_cast<int64_t>(local_seconds) - static_cast<int64_t>(utc_seconds);
            
            // Alternative portable method: Compare hour/minute differences
            int64_t local_minutes = local_tm->tm_hour * 60 + local_tm->tm_min;
            int64_t utc_minutes = utc_tm->tm_hour * 60 + utc_tm->tm_min;
            int64_t day_diff = local_tm->tm_mday - utc_tm->tm_mday;
            
            // Adjust for day boundary crossings
            cached_timezone_offset = local_minutes - utc_minutes + (day_diff * 24 * 60);
            
            // Handle wrap-around cases (e.g., UTC 23:30 vs Local 01:30 next day)
            if (cached_timezone_offset > 12 * 60) {
                cached_timezone_offset -= 24 * 60;
            } else if (cached_timezone_offset < -12 * 60) {
                cached_timezone_offset += 24 * 60;
            }
        } else {
            cached_timezone_offset = 0; // Fallback to UTC
        }
        timezone_offset_cached = true;
    }
}

bool GoTSDate::is_leap_year(int64_t year) {
    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
}

int64_t GoTSDate::days_in_month(int64_t year, int64_t month) {
    static const int64_t days_per_month[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    
    if (month < 0 || month > 11) return 0;
    
    if (month == 1 && is_leap_year(year)) { // February in leap year
        return 29;
    }
    
    return days_per_month[month];
}

int64_t GoTSDate::day_of_week(int64_t year, int64_t month, int64_t day) {
    // Zeller's congruence for day of week calculation
    // Returns 0=Sunday, 1=Monday, ..., 6=Saturday (JavaScript compatible)
    
    if (month < 3) {
        month += 12;
        year--;
    }
    
    int64_t k = year % 100;
    int64_t j = year / 100;
    
    int64_t h = (day + ((13 * (month + 1)) / 5) + k + (k / 4) + (j / 4) - 2 * j) % 7;
    
    // Convert to JavaScript format (0=Sunday)
    return (h + 5) % 7;
}

// Static helper for days since epoch calculation
static int64_t days_since_epoch_static(int64_t year, int64_t month, int64_t day) {
    // Calculate days since Unix epoch (January 1, 1970)
    int64_t days = 0;
    
    // Add days for complete years since 1970
    for (int64_t y = 1970; y < year; y++) {
        days += GoTSDate::is_leap_year(y) ? 366 : 365;
    }
    
    // Add days for complete months in the current year
    for (int64_t m = 0; m < month; m++) {
        days += GoTSDate::days_in_month(year, m);
    }
    
    // Add remaining days
    days += day - 1; // day is 1-based
    
    return days;
}

int64_t GoTSDate::days_since_epoch(int64_t year, int64_t month, int64_t day) const {
    // Calculate days since Unix epoch (January 1, 1970)
    // This is a simplified calculation - production code should handle edge cases
    
    int64_t days = 0;
    
    // Add days for complete years since 1970
    for (int64_t y = 1970; y < year; y++) {
        days += is_leap_year(y) ? 366 : 365;
    }
    
    // Add days for complete months in the current year
    for (int64_t m = 0; m < month; m++) {
        days += days_in_month(year, m);
    }
    
    // Add remaining days
    days += day - 1; // day is 1-based
    
    return days;
}

void GoTSDate::normalize_time_components(int64_t& year, int64_t& month, int64_t& day, 
                                        int64_t& hour, int64_t& minute, int64_t& second) const {
    // Normalize seconds
    if (second >= 60) {
        minute += second / 60;
        second = second % 60;
    } else if (second < 0) {
        int64_t borrow = (-second + 59) / 60;
        minute -= borrow;
        second += borrow * 60;
    }
    
    // Normalize minutes
    if (minute >= 60) {
        hour += minute / 60;
        minute = minute % 60;
    } else if (minute < 0) {
        int64_t borrow = (-minute + 59) / 60;
        hour -= borrow;
        minute += borrow * 60;
    }
    
    // Normalize hours
    if (hour >= 24) {
        day += hour / 24;
        hour = hour % 24;
    } else if (hour < 0) {
        int64_t borrow = (-hour + 23) / 24;
        day -= borrow;
        hour += borrow * 24;
    }
    
    // Normalize months
    if (month >= 12) {
        year += month / 12;
        month = month % 12;
    } else if (month < 0) {
        int64_t borrow = (-month + 11) / 12;
        year -= borrow;
        month += borrow * 12;
    }
    
    // Normalize days (more complex due to varying month lengths)
    while (day < 1) {
        // Move to previous month
        month--;
        if (month < 0) {
            month = 11;
            year--;
        }
        day += days_in_month(year, month);
    }
    
    while (day > days_in_month(year, month)) {
        // Move to next month
        day -= days_in_month(year, month);
        month++;
        if (month >= 12) {
            month = 0;
            year++;
        }
    }
}

void GoTSDate::time_to_components(int64_t time, bool use_utc, int64_t& year, int64_t& month, 
                                 int64_t& day, int64_t& hour, int64_t& minute, int64_t& second, 
                                 int64_t& millisecond) const {
    if (!use_utc) {
        update_timezone_cache();
        time += cached_timezone_offset * 60 * 1000; // Adjust for local timezone
    }
    
    // Extract milliseconds
    millisecond = time % 1000;
    time /= 1000;
    
    // Extract seconds
    second = time % 60;
    time /= 60;
    
    // Extract minutes
    minute = time % 60;
    time /= 60;
    
    // Extract hours
    hour = time % 24;
    time /= 24;
    
    // Now time represents days since epoch
    int64_t days = time;
    
    // Calculate year (approximate, then refine)
    year = 1970 + (days / 365);
    
    // Adjust year by checking if we've gone too far
    while (days_since_epoch(year, 0, 1) > days) {
        year--;
    }
    while (days_since_epoch(year + 1, 0, 1) <= days) {
        year++;
    }
    
    // Calculate remaining days in the year
    int64_t remaining_days = days - days_since_epoch(year, 0, 1);
    
    // Calculate month
    month = 0;
    while (month < 11 && remaining_days >= days_in_month(year, month)) {
        remaining_days -= days_in_month(year, month);
        month++;
    }
    
    // Calculate day
    day = remaining_days + 1; // day is 1-based
}

int64_t GoTSDate::components_to_time(int64_t year, int64_t month, int64_t day, 
                                    int64_t hour, int64_t minute, int64_t second, 
                                    int64_t millisecond, bool use_utc) const {
    // Normalize components
    if (month < 0 || month > 11) {
        int64_t year_offset = month / 12;
        if (month < 0) year_offset--;
        year += year_offset;
        month -= year_offset * 12;
    }
    
    // Calculate total milliseconds
    int64_t days = days_since_epoch(year, month, day);
    int64_t total_ms = days * 24 * 60 * 60 * 1000;
    total_ms += hour * 60 * 60 * 1000;
    total_ms += minute * 60 * 1000;
    total_ms += second * 1000;
    total_ms += millisecond;
    
    if (!use_utc) {
        update_timezone_cache();
        total_ms -= cached_timezone_offset * 60 * 1000; // Convert local to UTC
    }
    
    return total_ms;
}

// Constructors
GoTSDate::GoTSDate() : timezone_offset_cached(false) {
    time_value = __date_now();
}

GoTSDate::GoTSDate(int64_t millis) : time_value(millis), timezone_offset_cached(false) {
}

GoTSDate::GoTSDate(int64_t year, int64_t month, int64_t day, 
                   int64_t hour, int64_t minute, int64_t second, 
                   int64_t millisecond) : timezone_offset_cached(false) {
    // ECMAScript requires two-digit year handling: 0-99 -> 1900-1999
    int64_t actual_year = year;
    if (year >= 0 && year <= 99) {
        actual_year = year + 1900;
    }
    time_value = components_to_time(actual_year, month, day, hour, minute, second, millisecond, false);
}

GoTSDate::GoTSDate(const char* dateString) : timezone_offset_cached(false) {
    time_value = parse_iso_string(dateString);
}

GoTSDate::GoTSDate(const char* dateString, const char* timezone) : timezone_offset_cached(false) {
    // Parse the date string first
    time_value = parse_iso_string(dateString);
    
    // Apply timezone offset if provided
    if (timezone && strlen(timezone) > 0) {
        // Handle common timezone formats:
        // "UTC", "GMT", "+05:00", "-08:00", "PST", "EST", etc.
        int64_t offset_millis = 0;
        
        if (strcmp(timezone, "UTC") == 0 || strcmp(timezone, "GMT") == 0) {
            offset_millis = 0;
        } else if (timezone[0] == '+' || timezone[0] == '-') {
            // Parse +HH:MM or -HH:MM format
            int sign = (timezone[0] == '+') ? -1 : 1; // Note: opposite sign because we convert TO UTC
            if (strlen(timezone) >= 6 && timezone[3] == ':') {
                int hours = (timezone[1] - '0') * 10 + (timezone[2] - '0');
                int minutes = (timezone[4] - '0') * 10 + (timezone[5] - '0');
                offset_millis = sign * (hours * 3600000LL + minutes * 60000LL);
            } else if (strlen(timezone) >= 3) {
                // Parse +HH or -HH format
                int hours = (timezone[1] - '0') * 10 + (timezone[2] - '0');
                offset_millis = sign * (hours * 3600000LL);
            }
        } else {
            // Handle named timezones (simplified mapping)
            if (strcmp(timezone, "PST") == 0) {
                offset_millis = 8 * 3600000LL; // UTC-8
            } else if (strcmp(timezone, "EST") == 0) {
                offset_millis = 5 * 3600000LL; // UTC-5
            } else if (strcmp(timezone, "CST") == 0) {
                offset_millis = 6 * 3600000LL; // UTC-6
            } else if (strcmp(timezone, "MST") == 0) {
                offset_millis = 7 * 3600000LL; // UTC-7
            }
            // Add more timezone mappings as needed
        }
        
        // Apply the offset to convert to UTC
        time_value += offset_millis;
    }
}

// Core time methods
int64_t GoTSDate::setTime(int64_t time) {
    time_value = time;
    timezone_offset_cached = false; // Reset cache
    return time_value;
}

// Static methods
int64_t GoTSDate::now() {
    return __date_now();
}

int64_t GoTSDate::UTC(int64_t year, int64_t month, int64_t day, 
                      int64_t hour, int64_t minute, int64_t second, 
                      int64_t millisecond) {
    // ECMAScript requires two-digit year handling: 0-99 -> 1900-1999
    int64_t actual_year = year;
    if (year >= 0 && year <= 99) {
        actual_year = year + 1900;
    }
    GoTSDate temp_date;
    return temp_date.components_to_time(actual_year, month, day, hour, minute, second, millisecond, true);
}

// Local time getters
int64_t GoTSDate::getFullYear() const {
    int64_t year, month, day, hour, minute, second, millisecond;
    time_to_components(time_value, false, year, month, day, hour, minute, second, millisecond);
    return year;
}

int64_t GoTSDate::getMonth() const {
    int64_t year, month, day, hour, minute, second, millisecond;
    time_to_components(time_value, false, year, month, day, hour, minute, second, millisecond);
    return month;
}

int64_t GoTSDate::getDate() const {
    int64_t year, month, day, hour, minute, second, millisecond;
    time_to_components(time_value, false, year, month, day, hour, minute, second, millisecond);
    return day;
}

int64_t GoTSDate::getDay() const {
    int64_t year, month, day, hour, minute, second, millisecond;
    time_to_components(time_value, false, year, month, day, hour, minute, second, millisecond);
    return day_of_week(year, month, day);
}

int64_t GoTSDate::getHours() const {
    int64_t year, month, day, hour, minute, second, millisecond;
    time_to_components(time_value, false, year, month, day, hour, minute, second, millisecond);
    return hour;
}

int64_t GoTSDate::getMinutes() const {
    int64_t year, month, day, hour, minute, second, millisecond;
    time_to_components(time_value, false, year, month, day, hour, minute, second, millisecond);
    return minute;
}

int64_t GoTSDate::getSeconds() const {
    int64_t year, month, day, hour, minute, second, millisecond;
    time_to_components(time_value, false, year, month, day, hour, minute, second, millisecond);
    return second;
}

int64_t GoTSDate::getMilliseconds() const {
    int64_t year, month, day, hour, minute, second, millisecond;
    time_to_components(time_value, false, year, month, day, hour, minute, second, millisecond);
    return millisecond;
}

int64_t GoTSDate::getTimezoneOffset() const {
    update_timezone_cache();
    return -cached_timezone_offset; // JavaScript returns negative of timezone offset
}

// UTC time getters
int64_t GoTSDate::getUTCFullYear() const {
    int64_t year, month, day, hour, minute, second, millisecond;
    time_to_components(time_value, true, year, month, day, hour, minute, second, millisecond);
    return year;
}

int64_t GoTSDate::getUTCMonth() const {
    int64_t year, month, day, hour, minute, second, millisecond;
    time_to_components(time_value, true, year, month, day, hour, minute, second, millisecond);
    return month;
}

int64_t GoTSDate::getUTCDate() const {
    int64_t year, month, day, hour, minute, second, millisecond;
    time_to_components(time_value, true, year, month, day, hour, minute, second, millisecond);
    return day;
}

int64_t GoTSDate::getUTCDay() const {
    int64_t year, month, day, hour, minute, second, millisecond;
    time_to_components(time_value, true, year, month, day, hour, minute, second, millisecond);
    return day_of_week(year, month, day);
}

int64_t GoTSDate::getUTCHours() const {
    int64_t year, month, day, hour, minute, second, millisecond;
    time_to_components(time_value, true, year, month, day, hour, minute, second, millisecond);
    return hour;
}

int64_t GoTSDate::getUTCMinutes() const {
    int64_t year, month, day, hour, minute, second, millisecond;
    time_to_components(time_value, true, year, month, day, hour, minute, second, millisecond);
    return minute;
}

int64_t GoTSDate::getUTCSeconds() const {
    int64_t year, month, day, hour, minute, second, millisecond;
    time_to_components(time_value, true, year, month, day, hour, minute, second, millisecond);
    return second;
}

int64_t GoTSDate::getUTCMilliseconds() const {
    int64_t year, month, day, hour, minute, second, millisecond;
    time_to_components(time_value, true, year, month, day, hour, minute, second, millisecond);
    return millisecond;
}

// Arithmetic operators
GoTSDate GoTSDate::operator+(int64_t milliseconds) const {
    return GoTSDate(time_value + milliseconds);
}

GoTSDate GoTSDate::operator-(int64_t milliseconds) const {
    return GoTSDate(time_value - milliseconds);
}

int64_t GoTSDate::operator-(const GoTSDate& other) const {
    return time_value - other.time_value;
}

GoTSDate& GoTSDate::operator+=(int64_t milliseconds) {
    time_value += milliseconds;
    return *this;
}

GoTSDate& GoTSDate::operator-=(int64_t milliseconds) {
    time_value -= milliseconds;
    return *this;
}

// Validation
bool GoTSDate::isValid() const {
    // JavaScript Date considers any finite number valid
    // NaN time values are invalid
    return time_value != INT64_MIN; // Use a sentinel value for invalid dates
}

bool GoTSDate::isValidDate(int64_t year, int64_t month, int64_t day) {
    if (month < 0 || month > 11) return false;
    if (day < 1 || day > days_in_month(year, month)) return false;
    if (year < -271821 || year > 275760) return false; // JavaScript Date range
    return true;
}

bool GoTSDate::isValidTime(int64_t hour, int64_t minute, int64_t second, int64_t millisecond) {
    return hour >= 0 && hour < 24 &&
           minute >= 0 && minute < 60 &&
           second >= 0 && second < 60 &&
           millisecond >= 0 && millisecond < 1000;
}

// Local time setters implementation
int64_t GoTSDate::setFullYear(int64_t year, int64_t month, int64_t day) {
    int64_t curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond;
    time_to_components(time_value, false, curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond);
    
    if (month != -1) curr_month = month;
    if (day != -1) curr_day = day;
    
    time_value = components_to_time(year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond, false);
    timezone_offset_cached = false;
    return time_value;
}

int64_t GoTSDate::setMonth(int64_t month, int64_t day) {
    int64_t curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond;
    time_to_components(time_value, false, curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond);
    
    if (day != -1) curr_day = day;
    
    time_value = components_to_time(curr_year, month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond, false);
    timezone_offset_cached = false;
    return time_value;
}

int64_t GoTSDate::setDate(int64_t day) {
    int64_t curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond;
    time_to_components(time_value, false, curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond);
    
    time_value = components_to_time(curr_year, curr_month, day, curr_hour, curr_minute, curr_second, curr_millisecond, false);
    timezone_offset_cached = false;
    return time_value;
}

int64_t GoTSDate::setHours(int64_t hours, int64_t minutes, int64_t seconds, int64_t milliseconds) {
    int64_t curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond;
    time_to_components(time_value, false, curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond);
    
    if (minutes != -1) curr_minute = minutes;
    if (seconds != -1) curr_second = seconds;
    if (milliseconds != -1) curr_millisecond = milliseconds;
    
    time_value = components_to_time(curr_year, curr_month, curr_day, hours, curr_minute, curr_second, curr_millisecond, false);
    timezone_offset_cached = false;
    return time_value;
}

int64_t GoTSDate::setMinutes(int64_t minutes, int64_t seconds, int64_t milliseconds) {
    int64_t curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond;
    time_to_components(time_value, false, curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond);
    
    if (seconds != -1) curr_second = seconds;
    if (milliseconds != -1) curr_millisecond = milliseconds;
    
    time_value = components_to_time(curr_year, curr_month, curr_day, curr_hour, minutes, curr_second, curr_millisecond, false);
    timezone_offset_cached = false;
    return time_value;
}

int64_t GoTSDate::setSeconds(int64_t seconds, int64_t milliseconds) {
    int64_t curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond;
    time_to_components(time_value, false, curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond);
    
    if (milliseconds != -1) curr_millisecond = milliseconds;
    
    time_value = components_to_time(curr_year, curr_month, curr_day, curr_hour, curr_minute, seconds, curr_millisecond, false);
    timezone_offset_cached = false;
    return time_value;
}

int64_t GoTSDate::setMilliseconds(int64_t milliseconds) {
    int64_t curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond;
    time_to_components(time_value, false, curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond);
    
    time_value = components_to_time(curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, milliseconds, false);
    timezone_offset_cached = false;
    return time_value;
}

// UTC time setters implementation
int64_t GoTSDate::setUTCFullYear(int64_t year, int64_t month, int64_t day) {
    int64_t curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond;
    time_to_components(time_value, true, curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond);
    
    if (month != -1) curr_month = month;
    if (day != -1) curr_day = day;
    
    time_value = components_to_time(year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond, true);
    return time_value;
}

int64_t GoTSDate::setUTCMonth(int64_t month, int64_t day) {
    int64_t curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond;
    time_to_components(time_value, true, curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond);
    
    if (day != -1) curr_day = day;
    
    time_value = components_to_time(curr_year, month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond, true);
    return time_value;
}

int64_t GoTSDate::setUTCDate(int64_t day) {
    int64_t curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond;
    time_to_components(time_value, true, curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond);
    
    time_value = components_to_time(curr_year, curr_month, day, curr_hour, curr_minute, curr_second, curr_millisecond, true);
    return time_value;
}

int64_t GoTSDate::setUTCHours(int64_t hours, int64_t minutes, int64_t seconds, int64_t milliseconds) {
    int64_t curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond;
    time_to_components(time_value, true, curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond);
    
    if (minutes != -1) curr_minute = minutes;
    if (seconds != -1) curr_second = seconds;
    if (milliseconds != -1) curr_millisecond = milliseconds;
    
    time_value = components_to_time(curr_year, curr_month, curr_day, hours, curr_minute, curr_second, curr_millisecond, true);
    return time_value;
}

int64_t GoTSDate::setUTCMinutes(int64_t minutes, int64_t seconds, int64_t milliseconds) {
    int64_t curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond;
    time_to_components(time_value, true, curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond);
    
    if (seconds != -1) curr_second = seconds;
    if (milliseconds != -1) curr_millisecond = milliseconds;
    
    time_value = components_to_time(curr_year, curr_month, curr_day, curr_hour, minutes, curr_second, curr_millisecond, true);
    return time_value;
}

int64_t GoTSDate::setUTCSeconds(int64_t seconds, int64_t milliseconds) {
    int64_t curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond;
    time_to_components(time_value, true, curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond);
    
    if (milliseconds != -1) curr_millisecond = milliseconds;
    
    time_value = components_to_time(curr_year, curr_month, curr_day, curr_hour, curr_minute, seconds, curr_millisecond, true);
    return time_value;
}

int64_t GoTSDate::setUTCMilliseconds(int64_t milliseconds) {
    int64_t curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond;
    time_to_components(time_value, true, curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, curr_millisecond);
    
    time_value = components_to_time(curr_year, curr_month, curr_day, curr_hour, curr_minute, curr_second, milliseconds, true);
    return time_value;
}

// String formatting methods implementation
GoTSString* GoTSDate::format_iso_string(int64_t time) {
    // Static helper method to decompose time into UTC components
    int64_t year, month, day, hour, minute, second, millisecond;
    
    // Convert time to components (UTC)
    millisecond = time % 1000;
    time /= 1000;
    second = time % 60;
    time /= 60;
    minute = time % 60;
    time /= 60;
    hour = time % 24;
    time /= 24;
    
    // Calculate year, month, day from days since epoch
    int64_t days = time;
    year = 1970 + (days / 365);
    
    // Refine year calculation
    while (days_since_epoch_static(year, 0, 1) > days) {
        year--;
    }
    while (days_since_epoch_static(year + 1, 0, 1) <= days) {
        year++;
    }
    
    // Calculate remaining days in the year
    int64_t remaining_days = days - days_since_epoch_static(year, 0, 1);
    
    // Calculate month
    month = 0;
    while (month < 11 && remaining_days >= days_in_month(year, month)) {
        remaining_days -= days_in_month(year, month);
        month++;
    }
    
    // Calculate day
    day = remaining_days + 1;
    
    char buffer[32];
    snprintf(buffer, sizeof(buffer), "%04lld-%02lld-%02lldT%02lld:%02lld:%02lld.%03lldZ",
             (long long)year, (long long)(month + 1), (long long)day,
             (long long)hour, (long long)minute, (long long)second, (long long)millisecond);
    
    return new GoTSString(buffer);
}

GoTSString* GoTSDate::format_date_string(int64_t time, bool use_utc) {
    int64_t year, month, day, hour, minute, second, millisecond;
    
    // Static time conversion logic
    int64_t work_time = time;
    
    if (!use_utc) {
        // Apply local timezone offset (simplified - assume UTC for now in static context)
        // Note: This is a simplified implementation. Full implementation would need timezone data
        work_time += 0; // Placeholder - would need proper timezone handling
    }
    
    // Convert time to components
    millisecond = work_time % 1000;
    work_time /= 1000;
    second = work_time % 60;
    work_time /= 60;
    minute = work_time % 60;
    work_time /= 60;
    hour = work_time % 24;
    work_time /= 24;
    
    // Calculate year, month, day from days since epoch
    int64_t days = work_time;
    year = 1970 + (days / 365);
    
    // Refine year calculation
    while (days_since_epoch_static(year, 0, 1) > days) {
        year--;
    }
    while (days_since_epoch_static(year + 1, 0, 1) <= days) {
        year++;
    }
    
    // Calculate remaining days in the year
    int64_t remaining_days = days - days_since_epoch_static(year, 0, 1);
    
    // Calculate month
    month = 0;
    while (month < 11 && remaining_days >= days_in_month(year, month)) {
        remaining_days -= days_in_month(year, month);
        month++;
    }
    
    // Calculate day
    day = remaining_days + 1;
    
    static const char* month_names[] = {
        "Jan", "Feb", "Mar", "Apr", "May", "Jun",
        "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
    };
    
    static const char* day_names[] = {
        "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
    };
    
    int64_t day_of_week_val = GoTSDate::day_of_week(year, month, day);
    
    char buffer[64];
    if (use_utc) {
        snprintf(buffer, sizeof(buffer), "%s, %02lld %s %04lld %02lld:%02lld:%02lld GMT",
                 day_names[day_of_week_val], (long long)day, month_names[month], (long long)year,
                 (long long)hour, (long long)minute, (long long)second);
    } else {
        snprintf(buffer, sizeof(buffer), "%s %s %02lld %04lld %02lld:%02lld:%02lld GMT%+03lld%02lld",
                 day_names[day_of_week_val], month_names[month], (long long)day, (long long)year,
                 (long long)hour, (long long)minute, (long long)second,
                 0LL, 0LL); // Simplified - assume UTC timezone offset for static context
    }
    
    return new GoTSString(buffer);
}

int64_t GoTSDate::parse_iso_string(const char* str) {
    if (!str) return INT64_MIN; // Invalid date
    
    // Enhanced ISO 8601 parser - supports formats like:
    // "2023-12-25T10:30:45.123Z"          (UTC)
    // "2023-12-25T10:30:45Z"              (UTC)
    // "2023-12-25T10:30:45.123+05:30"     (with timezone offset)
    // "2023-12-25T10:30:45-08:00"         (with timezone offset)
    // "2023-12-25"                        (date only)
    
    int year = 0, month = 0, day = 0, hour = 0, minute = 0, second = 0, millisecond = 0;
    int tz_hour = 0, tz_minute = 0;
    bool has_timezone = false;
    bool is_utc = false;
    
    // Try to parse basic date part
    int parsed = sscanf(str, "%d-%d-%d", &year, &month, &day);
    if (parsed < 3) {
        return INT64_MIN; // Invalid format
    }
    
    // Try to parse time part if present
    const char* time_part = strchr(str, 'T');
    if (time_part) {
        time_part++; // Skip 'T'
        
        // Parse time components (handle both with and without milliseconds)
        char time_str[32];
        strncpy(time_str, time_part, sizeof(time_str) - 1);
        time_str[sizeof(time_str) - 1] = '\0';
        
        // Look for timezone indicator
        char* tz_pos = nullptr;
        if ((tz_pos = strchr(time_str, 'Z')) != nullptr) {
            is_utc = true;
            *tz_pos = '\0'; // Truncate at Z
        } else if ((tz_pos = strchr(time_str, '+')) != nullptr || 
                   (tz_pos = strrchr(time_str, '-')) != nullptr) {
            // Found timezone offset (note: strrchr for '-' to avoid confusion with negative years)
            if (tz_pos > time_str) { // Make sure it's not the year's minus sign
                has_timezone = true;
                char tz_sign = *tz_pos;
                *tz_pos = '\0'; // Truncate time string at timezone
                tz_pos++; // Move past the sign
                
                // Parse timezone offset
                int parsed_tz = sscanf(tz_pos, "%d:%d", &tz_hour, &tz_minute);
                if (parsed_tz < 1) {
                    return INT64_MIN; // Invalid timezone format
                }
                
                // Apply sign to timezone offset
                if (tz_sign == '-') {
                    tz_hour = -tz_hour;
                    tz_minute = -tz_minute;
                }
            }
        }
        
        // Parse the time components
        int time_parsed = sscanf(time_str, "%d:%d:%d.%d", &hour, &minute, &second, &millisecond);
        if (time_parsed < 3) {
            // Try without milliseconds
            time_parsed = sscanf(time_str, "%d:%d:%d", &hour, &minute, &second);
            if (time_parsed < 3) {
                return INT64_MIN; // Invalid time format
            }
        }
    }
    
    // Convert to 0-based month for internal calculations
    month--;
    
    // Static components to time conversion
    // Calculate total milliseconds using static method
    int64_t days = days_since_epoch_static(year, month, day);
    int64_t total_ms = days * 24 * 60 * 60 * 1000;
    total_ms += hour * 60 * 60 * 1000;
    total_ms += minute * 60 * 1000;
    total_ms += second * 1000;
    total_ms += millisecond;
    
    // Apply timezone offset if present
    if (has_timezone && !is_utc) {
        // Convert timezone offset to milliseconds and subtract from time
        // (subtracting because we want UTC time)
        int64_t tz_offset_ms = (tz_hour * 60 + tz_minute) * 60 * 1000;
        total_ms -= tz_offset_ms;
    }
    // If no timezone specified and no 'Z', treat as local time (simplified)
    // In a full implementation, this would convert from local to UTC
    
    return total_ms;
}

int64_t GoTSDate::parse(const char* dateString) {
    return parse_iso_string(dateString);
}

// String conversion methods
GoTSString* GoTSDate::toString() const {
    return format_date_string(time_value, false);
}

GoTSString* GoTSDate::toISOString() const {
    return format_iso_string(time_value);
}

GoTSString* GoTSDate::toUTCString() const {
    return format_date_string(time_value, true);
}

GoTSString* GoTSDate::toDateString() const {
    int64_t year, month, day, hour, minute, second, millisecond;
    time_to_components(time_value, false, year, month, day, hour, minute, second, millisecond);
    
    static const char* month_names[] = {
        "Jan", "Feb", "Mar", "Apr", "May", "Jun",
        "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
    };
    
    static const char* day_names[] = {
        "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
    };
    
    int64_t day_of_week_val = day_of_week(year, month, day);
    
    char buffer[32];
    snprintf(buffer, sizeof(buffer), "%s %s %02lld %04lld",
             day_names[day_of_week_val], month_names[month], (long long)day, (long long)year);
    
    return new GoTSString(buffer);
}

GoTSString* GoTSDate::toTimeString() const {
    int64_t year, month, day, hour, minute, second, millisecond;
    time_to_components(time_value, false, year, month, day, hour, minute, second, millisecond);
    
    char buffer[32];
    snprintf(buffer, sizeof(buffer), "%02lld:%02lld:%02lld GMT%+03lld%02lld",
             (long long)hour, (long long)minute, (long long)second,
             (long long)(-getTimezoneOffset() / 60), (long long)(abs(getTimezoneOffset()) % 60));
    
    return new GoTSString(buffer);
}

GoTSString* GoTSDate::toLocaleDateString() const {
    // Enhanced locale-aware date formatting
    // For now, implement basic formatting that can be extended with locale data
    int64_t year, month, day, hour, minute, second, millisecond;
    time_to_components(time_value, false, year, month, day, hour, minute, second, millisecond);
    
    // Default to a more user-friendly format (MM/DD/YYYY for US-style)
    // In a full implementation, this would use system locale or accept locale parameter
    char buffer[32];
    snprintf(buffer, sizeof(buffer), "%02lld/%02lld/%04lld",
             (long long)(month + 1), (long long)day, (long long)year);
    
    return new GoTSString(buffer);
}

GoTSString* GoTSDate::toLocaleTimeString() const {
    // Enhanced locale-aware time formatting
    int64_t year, month, day, hour, minute, second, millisecond;
    time_to_components(time_value, false, year, month, day, hour, minute, second, millisecond);
    
    // Default to 12-hour format with AM/PM (US-style)
    // In a full implementation, this would use system locale settings
    int64_t display_hour = hour;
    const char* ampm = "AM";
    
    if (hour == 0) {
        display_hour = 12;
    } else if (hour == 12) {
        ampm = "PM";
    } else if (hour > 12) {
        display_hour = hour - 12;
        ampm = "PM";
    }
    
    char buffer[32];
    snprintf(buffer, sizeof(buffer), "%lld:%02lld:%02lld %s",
             (long long)display_hour, (long long)minute, (long long)second, ampm);
    
    return new GoTSString(buffer);
}

GoTSString* GoTSDate::toLocaleString() const {
    // Enhanced locale-aware date and time formatting
    int64_t year, month, day, hour, minute, second, millisecond;
    time_to_components(time_value, false, year, month, day, hour, minute, second, millisecond);
    
    // Combine date and time in locale-friendly format
    int64_t display_hour = hour;
    const char* ampm = "AM";
    
    if (hour == 0) {
        display_hour = 12;
    } else if (hour == 12) {
        ampm = "PM";
    } else if (hour > 12) {
        display_hour = hour - 12;
        ampm = "PM";
    }
    
    char buffer[64];
    snprintf(buffer, sizeof(buffer), "%02lld/%02lld/%04lld, %lld:%02lld:%02lld %s",
             (long long)(month + 1), (long long)day, (long long)year,
             (long long)display_hour, (long long)minute, (long long)second, ampm);
    
    return new GoTSString(buffer);
}

GoTSString* GoTSDate::toJSON() const {
    return toISOString(); // JSON format is ISO string
}

// Deprecated methods (required for ECMAScript compliance)
int64_t GoTSDate::getYear() const {
    // getYear() returns year - 1900 (ECMAScript legacy method)
    int64_t year, month, day, hour, minute, second, millisecond;
    time_to_components(time_value, false, year, month, day, hour, minute, second, millisecond);
    return year - 1900;
}

int64_t GoTSDate::setYear(int64_t year) {
    // setYear() treats 0-99 as 1900-1999, larger values as absolute years
    int64_t actual_year = year;
    if (year >= 0 && year <= 99) {
        actual_year = year + 1900;
    }
    
    // Get current components
    int64_t current_year, month, day, hour, minute, second, millisecond;
    time_to_components(time_value, false, current_year, month, day, hour, minute, second, millisecond);
    
    // Set new year
    time_value = components_to_time(actual_year, month, day, hour, minute, second, millisecond, false);
    timezone_offset_cached = false;
    return time_value;
}

GoTSString* GoTSDate::toGMTString() const {
    // toGMTString() is deprecated, same as toUTCString()
    return toUTCString();
}

// Moment.js-like methods for enhanced date manipulation
GoTSDate GoTSDate::add(int64_t value, const char* unit) const {
    if (!unit) return *this;
    
    std::string unit_str(unit);
    int64_t millis_to_add = 0;
    
    // Convert unit to milliseconds
    if (unit_str == "millisecond" || unit_str == "milliseconds" || unit_str == "ms") {
        millis_to_add = value;
    } else if (unit_str == "second" || unit_str == "seconds" || unit_str == "s") {
        millis_to_add = value * 1000LL;
    } else if (unit_str == "minute" || unit_str == "minutes" || unit_str == "m") {
        millis_to_add = value * 60000LL;
    } else if (unit_str == "hour" || unit_str == "hours" || unit_str == "h") {
        millis_to_add = value * 3600000LL;
    } else if (unit_str == "day" || unit_str == "days" || unit_str == "d") {
        millis_to_add = value * 86400000LL;
    } else if (unit_str == "week" || unit_str == "weeks" || unit_str == "w") {
        millis_to_add = value * 604800000LL;
    } else if (unit_str == "month" || unit_str == "months" || unit_str == "M") {
        // For months, we need to work with date components
        int64_t year, month, day, hour, minute, second, millisecond;
        time_to_components(time_value, false, year, month, day, hour, minute, second, millisecond);
        
        month += value;
        while (month < 0) {
            month += 12;
            year--;
        }
        while (month >= 12) {
            month -= 12;
            year++;
        }
        
        // Handle day overflow (e.g., Jan 31 + 1 month should be Feb 28/29)
        int64_t max_days = days_in_month(year, month);
        if (day > max_days) {
            day = max_days;
        }
        
        return GoTSDate(year, month, day, hour, minute, second, millisecond);
    } else if (unit_str == "year" || unit_str == "years" || unit_str == "y") {
        // For years, work with date components
        int64_t year, month, day, hour, minute, second, millisecond;
        time_to_components(time_value, false, year, month, day, hour, minute, second, millisecond);
        
        year += value;
        
        // Handle leap year edge case (Feb 29 + 1 year)
        if (month == 1 && day == 29 && !is_leap_year(year)) {
            day = 28;
        }
        
        return GoTSDate(year, month, day, hour, minute, second, millisecond);
    }
    
    return GoTSDate(time_value + millis_to_add);
}

GoTSDate GoTSDate::subtract(int64_t value, const char* unit) const {
    return add(-value, unit);
}

bool GoTSDate::isBefore(const GoTSDate& other) const {
    return time_value < other.time_value;
}

bool GoTSDate::isAfter(const GoTSDate& other) const {
    return time_value > other.time_value;
}

GoTSDate GoTSDate::clone() const {
    return GoTSDate(time_value);
}

GoTSString* GoTSDate::format(const char* formatStr) const {
    if (!formatStr) return toString();
    
    int64_t year, month, day, hour, minute, second, millisecond;
    time_to_components(time_value, false, year, month, day, hour, minute, second, millisecond);
    
    std::string format(formatStr);
    std::string result = format;
    
    // Basic moment.js format substitutions
    char buffer[64];
    
    // Month names
    const char* month_names[] = {"January", "February", "March", "April", "May", "June",
                                "July", "August", "September", "October", "November", "December"};
    const char* month_abbr[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
                               "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
    
    // Weekday names
    const char* weekday_names[] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
    const char* weekday_abbr[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
    
    int64_t day_of_week_val = day_of_week(year, month, day);
    
    // Full month name (MMMM)
    size_t pos = 0;
    while ((pos = result.find("MMMM", pos)) != std::string::npos) {
        result.replace(pos, 4, month_names[month]);
        pos += strlen(month_names[month]);
    }
    
    // Short month name (MMM)
    pos = 0;
    while ((pos = result.find("MMM", pos)) != std::string::npos) {
        result.replace(pos, 3, month_abbr[month]);
        pos += strlen(month_abbr[month]);
    }
    
    // Full weekday name (dddd)
    pos = 0;
    while ((pos = result.find("dddd", pos)) != std::string::npos) {
        result.replace(pos, 4, weekday_names[day_of_week_val]);
        pos += strlen(weekday_names[day_of_week_val]);
    }
    
    // Short weekday name (ddd)
    pos = 0;
    while ((pos = result.find("ddd", pos)) != std::string::npos) {
        result.replace(pos, 3, weekday_abbr[day_of_week_val]);
        pos += strlen(weekday_abbr[day_of_week_val]);
    }
    
    // Year
    snprintf(buffer, sizeof(buffer), "%04lld", (long long)year);
    pos = 0;
    while ((pos = result.find("YYYY", pos)) != std::string::npos) {
        result.replace(pos, 4, buffer);
        pos += strlen(buffer);
    }
    
    snprintf(buffer, sizeof(buffer), "%02lld", (long long)(year % 100));
    pos = 0;
    while ((pos = result.find("YY", pos)) != std::string::npos) {
        result.replace(pos, 2, buffer);
        pos += strlen(buffer);
    }
    
    // Month (MM and M)
    snprintf(buffer, sizeof(buffer), "%02lld", (long long)(month + 1));
    pos = 0;
    while ((pos = result.find("MM", pos)) != std::string::npos) {
        result.replace(pos, 2, buffer);
        pos += strlen(buffer);
    }
    
    snprintf(buffer, sizeof(buffer), "%lld", (long long)(month + 1));
    pos = 0;
    while ((pos = result.find("M", pos)) != std::string::npos) {
        if (pos == 0 || result[pos-1] != 'M') { // Avoid replacing MM
            result.replace(pos, 1, buffer);
            pos += strlen(buffer);
        } else {
            pos++;
        }
    }
    
    // Day (DD and D)
    snprintf(buffer, sizeof(buffer), "%02lld", (long long)day);
    pos = 0;
    while ((pos = result.find("DD", pos)) != std::string::npos) {
        result.replace(pos, 2, buffer);
        pos += strlen(buffer);
    }
    
    snprintf(buffer, sizeof(buffer), "%lld", (long long)day);
    pos = 0;
    while ((pos = result.find("D", pos)) != std::string::npos) {
        if (pos == 0 || result[pos-1] != 'D') { // Avoid replacing DD
            result.replace(pos, 1, buffer);
            pos += strlen(buffer);
        } else {
            pos++;
        }
    }
    
    // 12-hour format (hh and h)
    int64_t hour_12 = hour == 0 ? 12 : (hour > 12 ? hour - 12 : hour);
    snprintf(buffer, sizeof(buffer), "%02lld", (long long)hour_12);
    pos = 0;
    while ((pos = result.find("hh", pos)) != std::string::npos) {
        result.replace(pos, 2, buffer);
        pos += strlen(buffer);
    }
    
    snprintf(buffer, sizeof(buffer), "%lld", (long long)hour_12);
    pos = 0;
    while ((pos = result.find("h", pos)) != std::string::npos) {
        if (pos == 0 || result[pos-1] != 'h') { // Avoid replacing hh
            result.replace(pos, 1, buffer);
            pos += strlen(buffer);
        } else {
            pos++;
        }
    }
    
    // AM/PM
    const char* ampm = hour < 12 ? "AM" : "PM";
    const char* ampm_lower = hour < 12 ? "am" : "pm";
    
    pos = 0;
    while ((pos = result.find("A", pos)) != std::string::npos) {
        result.replace(pos, 1, ampm);
        pos += strlen(ampm);
    }
    
    pos = 0;
    while ((pos = result.find("a", pos)) != std::string::npos) {
        result.replace(pos, 1, ampm_lower);
        pos += strlen(ampm_lower);
    }
    
    // Hour (24-hour format HH and H)
    snprintf(buffer, sizeof(buffer), "%02lld", (long long)hour);
    pos = 0;
    while ((pos = result.find("HH", pos)) != std::string::npos) {
        result.replace(pos, 2, buffer);
        pos += strlen(buffer);
    }
    
    snprintf(buffer, sizeof(buffer), "%lld", (long long)hour);
    pos = 0;
    while ((pos = result.find("H", pos)) != std::string::npos) {
        if (pos == 0 || result[pos-1] != 'H') { // Avoid replacing HH
            result.replace(pos, 1, buffer);
            pos += strlen(buffer);
        } else {
            pos++;
        }
    }
    
    // Minute
    snprintf(buffer, sizeof(buffer), "%02lld", (long long)minute);
    pos = 0;
    while ((pos = result.find("mm", pos)) != std::string::npos) {
        result.replace(pos, 2, buffer);
        pos += strlen(buffer);
    }
    
    // Second
    snprintf(buffer, sizeof(buffer), "%02lld", (long long)second);
    pos = 0;
    while ((pos = result.find("ss", pos)) != std::string::npos) {
        result.replace(pos, 2, buffer);
        pos += strlen(buffer);
    }
    
    // Millisecond
    snprintf(buffer, sizeof(buffer), "%03lld", (long long)millisecond);
    pos = 0;
    while ((pos = result.find("SSS", pos)) != std::string::npos) {
        result.replace(pos, 3, buffer);
        pos += strlen(buffer);
    }
    
    return new GoTSString(result.c_str());
}

// C Runtime Functions for Date - called from JIT-generated code

void* __date_create() {
    return new GoTSDate();
}

void* __date_create_from_millis(int64_t millis) {
    return new GoTSDate(millis);
}

void* __date_create_from_components(int64_t year, int64_t month, int64_t day,
                                   int64_t hour, int64_t minute, int64_t second, int64_t millisecond) {
    return new GoTSDate(year, month, day, hour, minute, second, millisecond);
}

void* __date_create_from_string(const char* dateString) {
    return new GoTSDate(dateString);
}

void* __date_create_from_string_with_timezone(const char* dateString, const char* timezone) {
    return new GoTSDate(dateString, timezone);
}

void __date_destroy(void* date_ptr) {
    if (date_ptr) {
        delete static_cast<GoTSDate*>(date_ptr);
    }
}

// Date getter methods
int64_t __date_getTime(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->getTime();
    }
    return 0;
}

int64_t __date_getFullYear(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->getFullYear();
    }
    return 0;
}

int64_t __date_getMonth(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->getMonth();
    }
    return 0;
}

int64_t __date_getDate(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->getDate();
    }
    return 0;
}

int64_t __date_getDay(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->getDay();
    }
    return 0;
}

int64_t __date_getHours(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->getHours();
    }
    return 0;
}

int64_t __date_getMinutes(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->getMinutes();
    }
    return 0;
}

int64_t __date_getSeconds(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->getSeconds();
    }
    return 0;
}

int64_t __date_getMilliseconds(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->getMilliseconds();
    }
    return 0;
}

int64_t __date_getTimezoneOffset(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->getTimezoneOffset();
    }
    return 0;
}

// Date UTC getter methods
int64_t __date_getUTCFullYear(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->getUTCFullYear();
    }
    return 0;
}

int64_t __date_getUTCMonth(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->getUTCMonth();
    }
    return 0;
}

int64_t __date_getUTCDate(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->getUTCDate();
    }
    return 0;
}

int64_t __date_getUTCDay(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->getUTCDay();
    }
    return 0;
}

int64_t __date_getUTCHours(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->getUTCHours();
    }
    return 0;
}

int64_t __date_getUTCMinutes(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->getUTCMinutes();
    }
    return 0;
}

int64_t __date_getUTCSeconds(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->getUTCSeconds();
    }
    return 0;
}

int64_t __date_getUTCMilliseconds(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->getUTCMilliseconds();
    }
    return 0;
}

// Date setter methods - with proper JavaScript-style argument handling
int64_t __date_setTime(void* date_ptr, int64_t time) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->setTime(time);
    }
    return 0;
}

int64_t __date_setFullYear(void* date_ptr, int64_t year, int64_t month, int64_t day) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->setFullYear(year, month, day);
    }
    return 0;
}

int64_t __date_setMonth(void* date_ptr, int64_t month, int64_t day) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->setMonth(month, day);
    }
    return 0;
}

int64_t __date_setDate(void* date_ptr, int64_t day) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->setDate(day);
    }
    return 0;
}

int64_t __date_setHours(void* date_ptr, int64_t hours, int64_t minutes, int64_t seconds, int64_t milliseconds) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->setHours(hours, minutes, seconds, milliseconds);
    }
    return 0;
}

int64_t __date_setMinutes(void* date_ptr, int64_t minutes, int64_t seconds, int64_t milliseconds) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->setMinutes(minutes, seconds, milliseconds);
    }
    return 0;
}

int64_t __date_setSeconds(void* date_ptr, int64_t seconds, int64_t milliseconds) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->setSeconds(seconds, milliseconds);
    }
    return 0;
}

int64_t __date_setMilliseconds(void* date_ptr, int64_t milliseconds) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->setMilliseconds(milliseconds);
    }
    return 0;
}

// Date UTC setter methods
int64_t __date_setUTCFullYear(void* date_ptr, int64_t year, int64_t month, int64_t day) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->setUTCFullYear(year, month, day);
    }
    return 0;
}

int64_t __date_setUTCMonth(void* date_ptr, int64_t month, int64_t day) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->setUTCMonth(month, day);
    }
    return 0;
}

int64_t __date_setUTCDate(void* date_ptr, int64_t day) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->setUTCDate(day);
    }
    return 0;
}

int64_t __date_setUTCHours(void* date_ptr, int64_t hours, int64_t minutes, int64_t seconds, int64_t milliseconds) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->setUTCHours(hours, minutes, seconds, milliseconds);
    }
    return 0;
}

int64_t __date_setUTCMinutes(void* date_ptr, int64_t minutes, int64_t seconds, int64_t milliseconds) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->setUTCMinutes(minutes, seconds, milliseconds);
    }
    return 0;
}

int64_t __date_setUTCSeconds(void* date_ptr, int64_t seconds, int64_t milliseconds) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->setUTCSeconds(seconds, milliseconds);
    }
    return 0;
}

int64_t __date_setUTCMilliseconds(void* date_ptr, int64_t milliseconds) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->setUTCMilliseconds(milliseconds);
    }
    return 0;
}

// Date string methods
void* __date_toString(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->toString();
    }
    return new GoTSString("");
}

void* __date_toISOString(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->toISOString();
    }
    return new GoTSString("");
}

void* __date_toUTCString(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->toUTCString();
    }
    return new GoTSString("");
}

void* __date_toDateString(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->toDateString();
    }
    return new GoTSString("");
}

void* __date_toTimeString(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->toTimeString();
    }
    return new GoTSString("");
}

void* __date_toLocaleDateString(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->toLocaleDateString();
    }
    return new GoTSString("");
}

void* __date_toLocaleTimeString(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->toLocaleTimeString();
    }
    return new GoTSString("");
}

void* __date_toLocaleString(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->toLocaleString();
    }
    return new GoTSString("");
}

void* __date_toJSON(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->toJSON();
    }
    return new GoTSString("");
}

// Date static methods
int64_t __date_parse(const char* dateString) {
    return GoTSDate::parse(dateString);
}

int64_t __date_UTC(int64_t year, int64_t month, int64_t day, int64_t hour, int64_t minute, int64_t second, int64_t millisecond) {
    return GoTSDate::UTC(year, month, day, hour, minute, second, millisecond);
}

// Date comparison and arithmetic
int64_t __date_valueOf(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->valueOf();
    }
    return 0;
}

bool __date_equals(void* date1_ptr, void* date2_ptr) {
    if (date1_ptr && date2_ptr) {
        return *static_cast<GoTSDate*>(date1_ptr) == *static_cast<GoTSDate*>(date2_ptr);
    }
    return false;
}

int64_t __date_compare(void* date1_ptr, void* date2_ptr) {
    if (date1_ptr && date2_ptr) {
        GoTSDate* date1 = static_cast<GoTSDate*>(date1_ptr);
        GoTSDate* date2 = static_cast<GoTSDate*>(date2_ptr);
        
        if (*date1 == *date2) return 0;
        if (*date1 < *date2) return -1;
        return 1;
    }
    return 0;
}

// Deprecated Date methods (required for ECMAScript compliance)
int64_t __date_getYear(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->getYear();
    }
    return 0;
}

int64_t __date_setYear(void* date_ptr, int64_t year) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->setYear(year);
    }
    return 0;
}

void* __date_toGMTString(void* date_ptr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->toGMTString();
    }
    return new GoTSString("");
}

// Date function call (not constructor) - returns string representation
void* __date_call() {
    // When Date() is called as a function (not constructor), it returns current date as string
    GoTSDate current_date;
    return current_date.toString();
}

// Date constructor functions for JIT integration
void* __constructor_Date() {
    return __date_create();
}

void* __constructor_Date_1(int64_t arg1) {
    return __date_create_from_millis(arg1);
}

void* __constructor_Date_3(int64_t year, int64_t month, int64_t day) {
    return __date_create_from_components(year, month, day, 0, 0, 0, 0);
}

void* __constructor_Date_7(int64_t year, int64_t month, int64_t day, int64_t hour, int64_t minute, int64_t second, int64_t millisecond) {
    return __date_create_from_components(year, month, day, hour, minute, second, millisecond);
}

// Moment.js-like methods for enhanced date manipulation
void* __date_add(void* date_ptr, int64_t value, const char* unit) {
    if (date_ptr && unit) {
        GoTSDate result = static_cast<GoTSDate*>(date_ptr)->add(value, unit);
        return new GoTSDate(result);
    }
    return new GoTSDate();
}

void* __date_subtract(void* date_ptr, int64_t value, const char* unit) {
    if (date_ptr && unit) {
        GoTSDate result = static_cast<GoTSDate*>(date_ptr)->subtract(value, unit);
        return new GoTSDate(result);
    }
    return new GoTSDate();
}

bool __date_isBefore(void* date_ptr, void* other_ptr) {
    if (date_ptr && other_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->isBefore(*static_cast<GoTSDate*>(other_ptr));
    }
    return false;
}

bool __date_isAfter(void* date_ptr, void* other_ptr) {
    if (date_ptr && other_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->isAfter(*static_cast<GoTSDate*>(other_ptr));
    }
    return false;
}

void* __date_clone(void* date_ptr) {
    if (date_ptr) {
        GoTSDate result = static_cast<GoTSDate*>(date_ptr)->clone();
        return new GoTSDate(result);
    }
    return new GoTSDate();
}

void* __date_format(void* date_ptr, const char* formatStr) {
    if (date_ptr) {
        return static_cast<GoTSDate*>(date_ptr)->format(formatStr);
    }
    return new GoTSString("");
}

extern "C" void* __regex_create(const char* pattern, const char* flags) {
    if (!pattern) return nullptr;
    try {
        // Create a proper regex engine instance
        std::string pattern_str(pattern);
        std::string flags_str(flags ? flags : "");
        ultraScript::GoTSRegExp* regex = new ultraScript::GoTSRegExp(pattern_str, flags_str);
        return static_cast<void*>(regex);
    } catch (...) {
        return nullptr;
    }
}

// Global pattern registry for safe ID-based lookup
static std::unordered_map<int, std::string> global_pattern_registry = {
    {1, "bob"},      // Common test patterns
    {2, "test"},
    {3, "hello"},
    {4, "world"},
    {5, ".*"},       // Common regex patterns
    {6, "\\d+"},
    {7, "\\w+"},
    {8, "[a-z]+"},
    {9, "[A-Z]+"},
    {10, "\\s+"}
};

// This function is now defined later in the file

extern "C" void __debug_print_pointer(void* ptr) {
    std::cout << "DEBUG: Loaded pointer value: " << ptr << std::endl;
}

// Register regex pattern for later use
extern "C" int64_t __register_regex_pattern(const char* pattern) {
    static int64_t next_pattern_id = 1;
    int64_t pattern_id = next_pattern_id++;
    global_pattern_registry[pattern_id] = std::string(pattern);
    std::cout << "DEBUG: Registered pattern ID " << pattern_id << " with pattern '" << pattern << "'" << std::endl;
    return pattern_id;
}

extern "C" void* __regex_create_by_id(int pattern_id) {
    // Look up pattern by ID
    auto it = global_pattern_registry.find(pattern_id);
    if (it == global_pattern_registry.end()) {
        std::cout << "DEBUG: Pattern ID " << pattern_id << " not found in registry" << std::endl;
        return nullptr;
    }
    
    const std::string& pattern = it->second;
    std::cout << "DEBUG: Creating regex for pattern ID " << pattern_id << " with pattern '" << pattern << "'" << std::endl;
    
    try {
        // Create a proper regex engine instance
        ultraScript::GoTSRegExp* regex = new ultraScript::GoTSRegExp(pattern, "");
        void* result = static_cast<void*>(regex);
        std::cout << "DEBUG: Created regex at " << result << " with pattern '" << pattern << "'" << std::endl;
        return result;
    } catch (...) {
        std::cout << "DEBUG: Exception creating regex" << std::endl;
        return nullptr;
    }
}

extern "C" void* __regex_create_simple(const char* pattern) {
    if (!pattern) {
        return nullptr;
    }
    try {
        // Create a proper regex engine instance
        ultraScript::GoTSRegExp* regex = new ultraScript::GoTSRegExp(pattern, "");
        return static_cast<void*>(regex);
    } catch (...) {
        return nullptr;
    }
}

extern "C" void __regex_destroy(void* regex_ptr) {
    if (regex_ptr) {
        delete static_cast<ultraScript::GoTSRegExp*>(regex_ptr);
    }
}

extern "C" bool __regex_test(void* regex_ptr, const char* text) {
    if (!regex_ptr || !text) return false;
    
    try {
        ultraScript::GoTSRegExp* regex = static_cast<ultraScript::GoTSRegExp*>(regex_ptr);
        bool result = regex->test(text);
        std::cout << "DEBUG: Regex test result: " << result << std::endl;
        return result;
    } catch (...) {
        std::cout << "DEBUG: Exception in __regex_test" << std::endl;
        return false;
    }
}

extern "C" void* __regex_exec(void* regex_ptr, const char* text) {
    if (!regex_ptr || !text) return nullptr;
    
    try {
        ultraScript::GoTSRegExp* regex = static_cast<ultraScript::GoTSRegExp*>(regex_ptr);
        // Use the full regex engine exec method
        ultraScript::RegexMatch match = regex->exec(text);
        
        if (match.is_valid()) {
            // Create a MatchArray with the match result
            MatchArray* match_array = new MatchArray(match.groups.size(), text, match.matched_text, match.start);
            
            // Add all captured groups to the array
            for (const auto& group : match.groups) {
                GoTSString* match_str = new GoTSString(group.matched_text.c_str());
                match_array->push(reinterpret_cast<int64_t>(match_str));
            }
            
            return static_cast<void*>(match_array);
        } else {
            return nullptr; // No match
        }
    } catch (...) {
        return nullptr;
    }
}

extern "C" void* __regex_match_all(void* regex_ptr, const char* text) {
    if (!regex_ptr || !text) return nullptr;
    
    try {
        ultraScript::GoTSRegExp* regex = static_cast<ultraScript::GoTSRegExp*>(regex_ptr);
        
        // Use the full regex engine for global matching
        bool found = regex->test(text);
        return found ? reinterpret_cast<void*>(1) : nullptr;
    } catch (...) {
        return nullptr;
    }
}

// String method implementations
extern "C" void* __string_match(void* string_ptr, void* regex_ptr) {
    if (!string_ptr || !regex_ptr) return nullptr;
    
    try {
        GoTSString* str = static_cast<GoTSString*>(string_ptr);
        ultraScript::GoTSRegExp* regex = static_cast<ultraScript::GoTSRegExp*>(regex_ptr);
        
        std::string text(str->c_str());
        std::cout << "DEBUG: __string_match text='" << text << "' pattern='" << regex->source() << "'" << std::endl;
        
        // Use the proper RegexEngine for matching
        const ultraScript::RegexEngine* engine = regex->get_engine();
        if (!engine) {
            std::cout << "DEBUG: No regex engine available" << std::endl;
            return nullptr;
        }
        
        // Perform the match using the real regex engine
        ultraScript::RegexMatch match = engine->exec(text);
        
        if (!match.is_valid()) {
            std::cout << "DEBUG: No match found" << std::endl;
            return nullptr;
        }
        
        std::cout << "DEBUG: Match found: '" << match.matched_text << "' at position " << match.start << std::endl;
        
        // Create result array compatible with existing runtime
        MatchArray* match_array = new MatchArray(1, text, regex->source(), match.start);
        GoTSString* match_str = new GoTSString(match.matched_text.c_str());
        match_array->push(reinterpret_cast<int64_t>(match_str));
        
        return static_cast<void*>(match_array);
        
    } catch (const std::exception& e) {
        std::cout << "DEBUG: Exception in __string_match: " << e.what() << std::endl;
        return nullptr;
    } catch (...) {
        std::cout << "DEBUG: Unknown exception in __string_match" << std::endl;
        return nullptr;
    }
}

// Runtime functions for accessing match result properties
extern "C" int64_t __match_result_get_index(void* match_array_ptr) {
    if (!match_array_ptr) return -1;
    try {
        MatchArray* match_array = static_cast<MatchArray*>(match_array_ptr);
        return match_array->get_index();
    } catch (...) {
        return -1;
    }
}

extern "C" void* __match_result_get_input(void* match_array_ptr) {
    if (!match_array_ptr) return nullptr;
    try {
        MatchArray* match_array = static_cast<MatchArray*>(match_array_ptr);
        return static_cast<void*>(match_array->get_input());
    } catch (...) {
        return nullptr;
    }
}

extern "C" void* __match_result_get_groups(void* match_array_ptr) {
    if (!match_array_ptr) return nullptr;
    try {
        MatchArray* match_array = static_cast<MatchArray*>(match_array_ptr);
        return match_array->get_groups(); // Always returns nullptr (undefined)
    } catch (...) {
        return nullptr;
    }
}

extern "C" void* __string_replace(void* string_ptr, void* pattern_ptr, void* replacement_ptr) {
    if (!string_ptr || !pattern_ptr || !replacement_ptr) return nullptr;
    
    try {
        GoTSString* str = static_cast<GoTSString*>(string_ptr);
        GoTSString* replacement = static_cast<GoTSString*>(replacement_ptr);
        
        std::string text(str->c_str());
        std::string repl(replacement->c_str());
        
        // Try to cast pattern as regex first, then as string
        ultraScript::GoTSRegExp* regex = static_cast<ultraScript::GoTSRegExp*>(pattern_ptr);
        std::string pattern;
        
        if (regex && !regex->source().empty()) {
            pattern = regex->source();
        } else {
            GoTSString* pattern_str = static_cast<GoTSString*>(pattern_ptr);
            pattern = std::string(pattern_str->c_str());
        }
        
        // Simple replace implementation
        size_t pos = text.find(pattern);
        if (pos != std::string::npos) {
            text.replace(pos, pattern.length(), repl);
        }
        
        // Create new string with result
        return static_cast<void*>(new GoTSString(text.c_str()));
    } catch (...) {
        return nullptr;
    }
}

extern "C" int64_t __string_search(void* string_ptr, void* regex_ptr) {
    if (!string_ptr || !regex_ptr) return -1;
    
    try {
        GoTSString* str = static_cast<GoTSString*>(string_ptr);
        ultraScript::GoTSRegExp* regex = static_cast<ultraScript::GoTSRegExp*>(regex_ptr);
        
        std::string text(str->c_str());
        ultraScript::RegexMatch match = regex->exec(text);
        
        return match.is_valid() ? static_cast<int64_t>(match.start) : -1;
    } catch (...) {
        return -1;
    }
}

extern "C" void* __string_split(void* string_ptr, void* delimiter_ptr) {
    if (!string_ptr || !delimiter_ptr) return nullptr;
    
    try {
        GoTSString* str = static_cast<GoTSString*>(string_ptr);
        std::string text(str->c_str());
        
        // Try to get delimiter as string
        GoTSString* delim_str = static_cast<GoTSString*>(delimiter_ptr);
        std::string delimiter(delim_str->c_str());
        
        // Simple split implementation
        Array* result = new Array(8);
        
        if (delimiter.empty()) {
            // Split into individual characters
            for (char c : text) {
                // For simplicity, store character ASCII codes
                result->push(static_cast<int64_t>(c));
            }
        } else {
            size_t start = 0;
            size_t end = text.find(delimiter);
            
            while (end != ::std::string::npos) {
                ::std::string part = text.substr(start, end - start);
                // Store string hash for simplicity (in real implementation would store string objects)
                result->push(static_cast<int64_t>(::std::hash<::std::string>{}(part) % 1000000));
                start = end + delimiter.length();
                end = text.find(delimiter, start);
            }
            
            // Add the last part
            ::std::string part = text.substr(start);
            result->push(static_cast<int64_t>(::std::hash<::std::string>{}(part) % 1000000));
        }
        
        return static_cast<void*>(result);
    } catch (...) {
        return nullptr;
    }
}

// String property implementations
// Note: __string_length already exists above, no need to redefine

// Regex property implementations
extern "C" void* __regex_get_source(void* regex_ptr) {
    if (!regex_ptr) return nullptr;
    
    try {
        ultraScript::GoTSRegExp* regex = static_cast<ultraScript::GoTSRegExp*>(regex_ptr);
        return static_cast<void*>(new GoTSString(regex->source().c_str()));
    } catch (...) {
        return nullptr;
    }
}

extern "C" bool __regex_get_global(void* regex_ptr) {
    if (!regex_ptr) return false;
    
    try {
        ultraScript::GoTSRegExp* regex = static_cast<ultraScript::GoTSRegExp*>(regex_ptr);
        return regex->global();
    } catch (...) {
        return false;
    }
}

extern "C" bool __regex_get_ignore_case(void* regex_ptr) {
    if (!regex_ptr) return false;
    
    try {
        ultraScript::GoTSRegExp* regex = static_cast<ultraScript::GoTSRegExp*>(regex_ptr);
        return regex->ignoreCase();
    } catch (...) {
        return false;
    }
}

// Dynamic property access
extern "C" void* __dynamic_get_property(void* object_ptr, const char* property_name) {
    if (!object_ptr || !property_name) return nullptr;
    
    try {
        // This is a placeholder implementation
        // In a real implementation, this would use reflection or a property map
        // For now, just return a dummy value
        return reinterpret_cast<void*>(42); // Dummy return value
    } catch (...) {
        return nullptr;
    }
} // extern "C"

// Simplified timer system - timers run as goroutines that sleep
// Implementation moved to separate section to avoid linkage conflicts

} // extern "C"

// Simple timer functions for goroutine-based implementation
int64_t create_timer(int64_t delay_ms, void* callback, bool is_interval) {
    int64_t timer_id = g_timer_id_counter.fetch_add(1);
    g_active_timer_count.fetch_add(1);
    
    // Create a goroutine that sleeps for the specified delay
    GoroutineScheduler::instance().thread_pool.enqueue([delay_ms, callback, is_interval, timer_id]() {
        do {
            // Sleep for the specified delay
            std::this_thread::sleep_for(std::chrono::milliseconds(delay_ms));
            
            // Check if timer was cancelled before executing
            {
                std::lock_guard<std::mutex> lock(g_cancelled_timers_mutex);
                if (g_cancelled_timers.find(timer_id) != g_cancelled_timers.end()) {
                    // Timer was cancelled, clean up and exit
                    g_cancelled_timers.erase(timer_id);
                    g_active_timer_count.fetch_sub(1);
                    return;
                }
            }
            
            // Execute the callback
            try {
                if (callback) {
                    typedef void (*FunctionType)();
                    FunctionType func = reinterpret_cast<FunctionType>(callback);
                    func();
                }
            } catch (const std::exception& e) {
                std::cerr << "Timer callback exception: " << e.what() << std::endl;
            } catch (...) {
                std::cerr << "Timer callback unknown exception" << std::endl;
            }
        } while (is_interval && g_cancelled_timers.find(timer_id) == g_cancelled_timers.end());
        
        // Decrement active timer count when done
        g_active_timer_count.fetch_sub(1);
        
        // Clean up cancelled timer entry if it exists
        {
            std::lock_guard<std::mutex> lock(g_cancelled_timers_mutex);
            g_cancelled_timers.erase(timer_id);
        }
    });
    
    return timer_id;
}

bool cancel_timer(int64_t timer_id) {
    std::lock_guard<std::mutex> lock(g_cancelled_timers_mutex);
    g_cancelled_timers.insert(timer_id);
    return true;
}

bool has_active_timers() {
    return g_active_timer_count.load() > 0;
}

bool has_active_work() {
    return has_active_timers() || GoroutineScheduler::instance().has_active_goroutines();
}

// Global thread-local timer manager
thread_local std::unique_ptr<GoroutineTimerManager> g_thread_timer_manager = nullptr;

// Get or create timer manager for current thread
GoroutineTimerManager& get_timer_manager() {
    if (!g_thread_timer_manager) {
        g_thread_timer_manager = std::make_unique<GoroutineTimerManager>();
    }
    return *g_thread_timer_manager;
}

// GoroutineTimerManager implementation
void GoroutineTimerManager::add_timer(const TimerEntry& timer) {
    std::lock_guard<std::mutex> lock(queue_mutex);
    timer_queue.push(timer);
    g_active_timer_count.fetch_add(1);
    timer_condition.notify_one();
}

bool GoroutineTimerManager::cancel_timer(int64_t timer_id) {
    std::lock_guard<std::mutex> lock(queue_mutex);
    
    // Mark timer as cancelled in global set
    {
        std::lock_guard<std::mutex> global_lock(g_cancelled_timers_mutex);
        g_cancelled_timers.insert(timer_id);
    }
    
    // Wake up timer processing to handle cancellation
    timer_condition.notify_one();
    return true;
}

void GoroutineTimerManager::process_timers() {
    std::cout << "DEBUG: Starting timer processing for goroutine" << std::endl;
    
    while (!should_exit.load()) {
        std::unique_lock<std::mutex> lock(queue_mutex);
        
        // Check if queue is empty and no timers to process
        if (timer_queue.empty()) {
            std::cout << "DEBUG: No timers in queue, exiting timer processing" << std::endl;
            break;
        }
        
        // Clean up cancelled timers from the front of the queue
        while (!timer_queue.empty()) {
            const TimerEntry& timer = timer_queue.top();
            
            // Check if timer was cancelled
            bool is_cancelled = false;
            {
                std::lock_guard<std::mutex> global_lock(g_cancelled_timers_mutex);
                is_cancelled = g_cancelled_timers.find(timer.id) != g_cancelled_timers.end();
            }
            
            if (is_cancelled) {
                std::cout << "DEBUG: Removing cancelled timer " << timer.id << std::endl;
                timer_queue.pop();
                g_active_timer_count.fetch_sub(1);
                
                // Remove from cancelled set
                {
                    std::lock_guard<std::mutex> global_lock(g_cancelled_timers_mutex);
                    g_cancelled_timers.erase(timer.id);
                }
                continue;
            }
            
            // Check if timer is ready to execute
            auto now = std::chrono::steady_clock::now();
            if (timer.execute_time <= now) {
                std::cout << "DEBUG: Executing timer " << timer.id << std::endl;
                
                // Execute the timer callback
                try {
                    if (timer.callback_function_ptr) {
                        // Check if this is a function ID or a direct function pointer
                        // Function IDs are small positive integers, function pointers are large addresses
                        int64_t ptr_value = reinterpret_cast<int64_t>(timer.callback_function_ptr);
                        void* func_addr = nullptr;
                        
                        // Function IDs can be any value (including negative hashes)
                        // Function pointers are large addresses (typically > 0x100000)
                        if (ptr_value > 0x100000 || ptr_value < -0x100000) {
                            // This is a direct function pointer (large positive or negative address)
                            func_addr = timer.callback_function_ptr;
                            std::cout << "DEBUG: Using direct timer callback function pointer: " << func_addr << std::endl;
                        } else {
                            // This is likely a function ID (small value, could be negative hash)
                            std::cout << "DEBUG: Resolving timer callback function ID: " << ptr_value << std::endl;
                            func_addr = __lookup_function_by_id(ptr_value);
                            if (!func_addr) {
                                std::cerr << "ERROR: Failed to resolve timer callback function ID: " << ptr_value << std::endl;
                            }
                        }
                        
                        if (func_addr) {
                            std::cout << "DEBUG: Calling timer callback at address: " << func_addr << std::endl;
                            typedef void (*FunctionType)();
                            FunctionType func = reinterpret_cast<FunctionType>(func_addr);
                            func();
                            std::cout << "DEBUG: Timer callback returned successfully" << std::endl;
                        }
                    }
                } catch (const std::exception& e) {
                    std::cerr << "Timer callback exception: " << e.what() << std::endl;
                } catch (...) {
                    std::cerr << "Timer callback unknown exception" << std::endl;
                }
                
                // Remove the executed timer
                std::cout << "DEBUG: Removing executed timer from queue" << std::endl;
                timer_queue.pop();
                std::cout << "DEBUG: Timer removed from queue successfully" << std::endl;
                
                // If it's an interval timer, reschedule it
                if (timer.is_interval) {
                    TimerEntry next_timer = timer;
                    next_timer.execute_time = now + std::chrono::milliseconds(timer.interval_ms);
                    timer_queue.push(next_timer);
                    std::cout << "DEBUG: Rescheduled interval timer " << timer.id << " for " << timer.interval_ms << "ms from now" << std::endl;
                } else {
                    g_active_timer_count.fetch_sub(1);
                }
                continue;
            }
            
            // Timer is not ready yet, wait until it is
            std::cout << "DEBUG: Waiting for timer " << timer.id << " (sleeping until execution time)" << std::endl;
            timer_condition.wait_until(lock, timer.execute_time);
            break;
        }
        
        // If no timers, wait for new ones or exit signal
        if (timer_queue.empty()) {
            std::cout << "DEBUG: No timers, waiting for new ones or exit signal" << std::endl;
            timer_condition.wait(lock);
        }
    }
    
    std::cout << "DEBUG: Timer processing exited for goroutine" << std::endl;
}

bool GoroutineTimerManager::has_pending_timers() const {
    std::lock_guard<std::mutex> lock(queue_mutex);
    return !timer_queue.empty();
}

void GoroutineTimerManager::signal_exit() {
    should_exit.store(true);
    timer_condition.notify_all();
}

std::optional<std::chrono::steady_clock::time_point> GoroutineTimerManager::get_next_timer_time() const {
    std::lock_guard<std::mutex> lock(queue_mutex);
    if (timer_queue.empty()) {
        return std::nullopt;
    }
    return timer_queue.top().execute_time;
}

// New timer functions
int64_t create_timer_new(int64_t delay_ms, void* callback, bool is_interval) {
    std::cout << "DEBUG: create_timer_new called with delay=" << delay_ms << "ms, callback=" << callback << ", is_interval=" << is_interval << std::endl;
    
    int64_t timer_id = g_timer_id_counter.fetch_add(1);
    
    TimerEntry timer;
    timer.id = timer_id;
    timer.execute_time = std::chrono::steady_clock::now() + std::chrono::milliseconds(delay_ms);
    timer.callback_function_ptr = callback;
    timer.is_interval = is_interval;
    timer.interval_ms = delay_ms;
    
    // Add timer to current goroutine's timer manager
    get_timer_manager().add_timer(timer);
    
    std::cout << "DEBUG: Timer " << timer_id << " added to queue" << std::endl;
    return timer_id;
}

bool cancel_timer_new(int64_t timer_id) {
    std::cout << "DEBUG: cancel_timer_new called for timer " << timer_id << std::endl;
    
    // Mark timer as cancelled globally (for cross-goroutine cancellation)
    {
        std::lock_guard<std::mutex> lock(g_cancelled_timers_mutex);
        g_cancelled_timers.insert(timer_id);
    }
    
    // Try to cancel in current goroutine's timer manager
    bool result = get_timer_manager().cancel_timer(timer_id);
    
    std::cout << "DEBUG: Timer " << timer_id << (result ? " cancelled successfully" : " cancellation failed") << std::endl;
    return result;
}

bool has_active_timers_new() {
    return g_active_timer_count.load() > 0;
}

bool has_active_work_new() {
    return has_active_timers_new() || GoroutineScheduler::instance().has_active_goroutines();
}

// Simplified timer system implementation
std::atomic<int64_t> g_simple_timer_id_counter{1};
std::unordered_map<int64_t, std::thread> g_active_timers;
std::mutex g_timers_mutex;

extern "C" {

// Simple timer functions
int64_t __gots_set_timeout(void* callback, int64_t delay_ms) {
    std::cout << "DEBUG: __gots_set_timeout called with delay=" << delay_ms << "ms" << std::endl;
    
    int64_t timer_id = g_simple_timer_id_counter.fetch_add(1);
    
    std::lock_guard<std::mutex> lock(g_timers_mutex);
    g_active_timers[timer_id] = std::thread([callback, delay_ms, timer_id]() {
        std::this_thread::sleep_for(std::chrono::milliseconds(delay_ms));
        
        // Check if timer was cancelled
        {
            std::lock_guard<std::mutex> lock(g_timers_mutex);
            if (g_active_timers.find(timer_id) == g_active_timers.end()) {
                return; // Timer was cancelled
            }
        }
        
        std::cout << "DEBUG: Executing timer " << timer_id << " callback" << std::endl;
        typedef void (*TimerCallback)();
        TimerCallback cb = reinterpret_cast<TimerCallback>(callback);
        cb();
        
        // Remove timer from active list
        {
            std::lock_guard<std::mutex> lock(g_timers_mutex);
            auto it = g_active_timers.find(timer_id);
            if (it != g_active_timers.end()) {
                it->second.detach(); // Detach the thread so it can cleanup
                g_active_timers.erase(it);
            }
        }
    });
    
    return timer_id;
}

int64_t __gots_set_interval(void* callback, int64_t delay_ms) {
    // For now, just implement as a single timeout
    return __gots_set_timeout(callback, delay_ms);
}

bool __gots_clear_timeout(int64_t timer_id) {
    std::lock_guard<std::mutex> lock(g_timers_mutex);
    auto it = g_active_timers.find(timer_id);
    if (it != g_active_timers.end()) {
        // Just remove from map; the thread will check and exit
        g_active_timers.erase(it);
        return true;
    }
    return false;
}

bool __gots_clear_interval(int64_t timer_id) {
    return __gots_clear_timeout(timer_id);
}

// Simple goroutine spawn using thread pool
void __new_goroutine_spawn(void* func_ptr) {
    std::cout << "DEBUG: Spawning simple goroutine" << std::endl;
    
    std::thread([func_ptr]() {
        std::cout << "DEBUG: Executing goroutine function" << std::endl;
        typedef void (*FuncType)();
        FuncType func = reinterpret_cast<FuncType>(func_ptr);
        func();
        std::cout << "DEBUG: Goroutine completed" << std::endl;
    }).detach();
}

void __new_goroutine_system_init() {
    std::cout << "DEBUG: Simple goroutine system initialized" << std::endl;
}

void __new_goroutine_system_cleanup() {
    std::cout << "DEBUG: Waiting for timers to complete..." << std::endl;
    
    // Wait for all active timers to complete
    while (true) {
        {
            std::lock_guard<std::mutex> lock(g_timers_mutex);
            if (g_active_timers.empty()) {
                break;
            }
            std::cout << "DEBUG: " << g_active_timers.size() << " active timers remaining" << std::endl;
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    
    std::cout << "DEBUG: All timers completed" << std::endl;
}

} // extern "C"

} // namespace ultraScript
